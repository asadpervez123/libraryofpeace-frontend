// /**
//  * turn.js 3rd release
//  * www.turnjs.com
//  *
//  * Copyright (C) 2012, Emmanuel Garcia.
//  * All rights reserved.
//  *
//  * Redistribution and use in source and binary forms, with or without
//  * modification, are permitted provided that the following conditions
//  * are met:
//  *
//  * 1. Redistributions of source code must retain the above copyright
//  * notice, this list of conditions and the following disclaimer.
//  *
//  * 2. Any redistribution, use, or modification is done solely for personal 
//  * benefit and not for any commercial purpose or for monetary gain.
//  * 
//  **/

// (function($) {

//     'use strict';
    
//     var has3d,
    
//         vendor ='',
    
//         PI = Math.PI,
    
//         A90 = PI/2,
    
//         isTouch = 'ontouchstart' in window,
    
//         events = (isTouch) ? {start: 'touchstart', move: 'touchmove', end: 'touchend'}
//                 : {start: 'mousedown', move: 'mousemove', end: 'mouseup'},
    
//         // Contansts used for each corner
//         // tl * tr
//         // *     *
//         // bl * br
    
//         corners = {
//             backward: ['bl', 'tl'],
//             forward: ['br', 'tr'],
//             all: ['tl', 'bl', 'tr', 'br']
//         },
    
//         displays = ['single', 'double'],
    
//         // Default options
    
//         turnOptions = {
    
//             // First page
    
//             page: 1,
            
//             // Enables gradients
    
//             gradients: true,
    
//             // Duration of transition in milliseconds
    
//             duration: 600,
    
//             // Enables hardware acceleration
    
//             acceleration: true,
    
//             // Display
    
//             display: 'double',
    
//             // Events
    
//             when: null
//         },
    
//         flipOptions = {
    
//             // Back page
            
//             folding: null,
    
//             // Corners
//             // backward: Activates both tl and bl corners
//             // forward: Activates both tr and br corners
//             // all: Activates all the corners
    
//             corners: 'forward',
            
//             // Size of the active zone of each corner
    
//             cornerSize: 100,
    
//             // Enables gradients
    
//             gradients: true,
    
//             // Duration of transition in milliseconds
    
//             duration: 600,
    
//             // Enables hardware acceleration
    
//             acceleration: true
//         },
    
//         // Number of pages in the DOM, minimum value: 6
    
//         pagesInDOM = 6,
        
//         pagePosition = {0: {top: 0, left: 0, right: 'auto', bottom: 'auto'},
//                         1: {top: 0, right: 0, left: 'auto', bottom: 'auto'}},
    
//         // Gets basic attributes for a layer
    
//         divAtt = function(top, left, zIndex, overf) {
//             return {'css': {
//                         position: 'absolute',
//                         top: top,
//                         left: left,
//                         'overflow': overf || 'hidden',
//                         'z-index': zIndex || 'auto'
//                         }
//                 };
//         },
    
//         // Gets a 2D point from a bezier curve of four points
    
//         bezier = function(p1, p2, p3, p4, t) {
//             var mum1 = 1 - t,
//                 mum13 = mum1 * mum1 * mum1,
//                 mu3 = t * t * t;
    
//             return point2D(Math.round(mum13*p1.x + 3*t*mum1*mum1*p2.x + 3*t*t*mum1*p3.x + mu3*p4.x),
//                             Math.round(mum13*p1.y + 3*t*mum1*mum1*p2.y + 3*t*t*mum1*p3.y + mu3*p4.y));
//         },
        
//         // Converts an angle from degrees to radians
    
//         rad = function(degrees) {
//             return degrees/180*PI;
//         },
    
//         // Converts an angle from radians to degrees
    
//         deg = function(radians) {
//             return radians/PI*180;
//         },
    
//         // Gets a 2D point
    
//         point2D = function(x, y) {
//             return {x: x, y: y};
//         },
    
//         // Returns the traslate value
    
//         translate = function(x, y, use3d) {
//             return (has3d && use3d) ? ' translate3d(' + x + 'px,' + y + 'px, 0px) ' : ' translate(' + x + 'px, ' + y + 'px) ';
//         },
    
//         // Returns the rotation value
    
//         rotate = function(degrees) {
//             return ' rotate(' + degrees + 'deg) ';
//         },
    
//         // Checks if a property belongs to an object
    
//         has = function(property, object) {
//             return Object.prototype.hasOwnProperty.call(object, property);
//         },
    
//         // Gets the CSS3 vendor prefix
    
//         getPrefix = function() {
//             var vendorPrefixes = ['Moz','Webkit','Khtml','O','ms'],
//                 len = vendorPrefixes.length,
//                 vendor = '';
    
//             while (len--)
//                 if ((vendorPrefixes[len] + 'Transform') in document.body.style)
//                     vendor='-'+vendorPrefixes[len].toLowerCase()+'-';
    
//             return vendor;
//         },
    
//         // Adds gradients
    
//         gradient = function(obj, p0, p1, colors, numColors) {
        
//             var j, cols = [];
    
//             if (vendor=='-webkit-') {
            
//                 for (j = 0; j<numColors; j++)
//                         cols.push('color-stop('+colors[j][0]+', '+colors[j][1]+')');
                
//                 obj.css({'background-image': '-webkit-gradient(linear, '+p0.x+'% '+p0.y+'%,  '+p1.x+'% '+p1.y+'%, '+ cols.join(',') +' )'});
    
//             } else {
    
//                 // This procedure makes the gradients for non-webkit browsers
//                 // It will be reduced to one unique way for gradients in next versions
                
//                 p0 = {x:p0.x/100 * obj.width(), y:p0.y/100 * obj.height()};
//                 p1 = {x:p1.x/100 * obj.width(), y:p1.y/100 * obj.height()};
    
//                 var dx = p1.x-p0.x,
//                     dy = p1.y-p0.y,
//                     angle = Math.atan2(dy, dx),
//                     angle2 = angle - Math.PI/2,
//                     diagonal = Math.abs(obj.width()*Math.sin(angle2)) + Math.abs(obj.height()*Math.cos(angle2)),
//                     gradientDiagonal = Math.sqrt(dy*dy + dx*dx),
//                     corner = point2D((p1.x<p0.x) ? obj.width() : 0, (p1.y<p0.y) ? obj.height() : 0),
//                     slope = Math.tan(angle),
//                     inverse = -1/slope,
//                     x = (inverse*corner.x - corner.y - slope*p0.x + p0.y) / (inverse-slope),
//                     c = {x: x, y: inverse*x - inverse*corner.x + corner.y},
//                     segA = (Math.sqrt( Math.pow(c.x-p0.x,2) + Math.pow(c.y-p0.y,2)));
    
//                     for (j = 0; j<numColors; j++)
//                         cols.push(' '+colors[j][1]+' '+(( segA + gradientDiagonal*colors[j][0] )*100/diagonal)+'%');
            
//                     obj.css({'background-image': vendor+'linear-gradient(' + (-angle) + 'rad,' + cols.join(',') + ')'});
//             }
//         },
    
//     turnMethods = {
    
//         // Singleton constructor
//         // $('#selector').turn([options]);
    
//         init: function(opts) {
    
//             // Define constants
//             if (has3d===undefined) {
//                 has3d = 'WebKitCSSMatrix' in window || 'MozPerspective' in document.body.style;
//                 vendor = getPrefix();
//             }
    
//             var i, data = this.data(), ch = this.children();
        
//             opts = $.extend({width: this.width(), height: this.height()}, turnOptions, opts);
//             data.opts = opts;
//             data.pageObjs = {};
//             data.pages = {};
//             data.pageWrap = {};
//             data.pagePlace = {};
//             data.pageMv = [];
//             data.totalPages = opts.pages || 0;
    
//             if (opts.when)
//                 for (i in opts.when)
//                     if (has(i, opts.when))
//                         this.bind(i, opts.when[i]);
    
    
//             this.css({position: 'relative', width: opts.width, height: opts.height});
    
//             this.turn('display', opts.display);
    
//             if (has3d && !isTouch && opts.acceleration)
//                 this.transform(translate(0, 0, true));
        
//             for (i = 0; i<ch.length; i++)
//                 this.turn('addPage', ch[i], i+1);
        
//             this.turn('page', opts.page);
    
//             // allow setting active corners as an option
//             corners = $.extend({}, corners, opts.corners);
    
//             // Event listeners
    
//             $(this).bind(events.start, function(e) {
//                 for (var page in data.pages)
//                     if (has(page, data.pages) && flipMethods._eventStart.call(data.pages[page], e)===false)
//                         return false;
//             });
                
//             $(document).bind(events.move, function(e) {
//                 for (var page in data.pages)
//                     if (has(page, data.pages))
//                         flipMethods._eventMove.call(data.pages[page], e);
//             }).
//             bind(events.end, function(e) {
//                 for (var page in data.pages)
//                     if (has(page, data.pages))
//                         flipMethods._eventEnd.call(data.pages[page], e);
    
//             });
    
//             data.done = true;
    
//             return this;
//         },
    
//         // Adds a page from external data
    
//         addPage: function(element, page) {
    
//             var incPages = false,
//                 data = this.data(),
//                 lastPage = data.totalPages+1;
    
//             if (page) {
//                 if (page==lastPage) {
//                     page = lastPage;
//                     incPages = true;
//                 } else if (page>lastPage)
//                     throw new Error ('It is impossible to add the page "'+page+'", the maximum value is: "'+lastPage+'"');
    
//             } else {
//                 page = lastPage;
//                 incPages = true;
//             }
    
//             if (page>=1 && page<=lastPage) {
    
//                 // Stop animations
//                 if (data.done) this.turn('stop');
    
//                 // Move pages if it's necessary
//                 if (page in data.pageObjs)
//                     turnMethods._movePages.call(this, page, 1);
    
//                 // Update number of pages
//                 if (incPages)
//                     data.totalPages = lastPage;
    
//                 // Add element
//                 data.pageObjs[page] = $(element).addClass('turn-page p' + page);
    
//                 // Add page
//                 turnMethods._addPage.call(this, page);
    
//                 // Update view
//                 if (data.done)
//                     this.turn('update');
    
//                 turnMethods._removeFromDOM.call(this);
//             }
    
//             return this;
//         },
    
//         // Adds a page from internal data
    
//         _addPage: function(page) {
            
//             var data = this.data(),
//                 element = data.pageObjs[page];
    
//             if (element)
//                 if (turnMethods._necessPage.call(this, page)) {
                    
//                     if (!data.pageWrap[page]) {
    
//                         var pageWidth = (data.display=='double') ? this.width()/2 : this.width(),
//                             pageHeight = this.height();
    
//                         element.css({width:pageWidth, height:pageHeight});
    
//                         // Place
//                         data.pagePlace[page] = page;
    
//                         // Wrapper
//                         data.pageWrap[page] = $('<div/>', {'class': 'turn-page-wrapper',
//                                                         page: page,
//                                                         css: {position: 'absolute',
//                                                         overflow: 'hidden',
//                                                         width: pageWidth,
//                                                         height: pageHeight}}).
//                                                         css(pagePosition[(data.display=='double') ? page%2 : 0]);
    
//                         // Append to this
//                         this.append(data.pageWrap[page]);
    
//                         // Move data.pageObjs[page] (element) to wrapper
//                         data.pageWrap[page].prepend(data.pageObjs[page]);
//                     }
    
//                     // If the page is in the current view, create the flip effect
//                     if (!page || turnMethods._setPageLoc.call(this, page)==1)
//                         turnMethods._makeFlip.call(this, page);
                    
//                 } else {
    
//                     // Place
//                     data.pagePlace[page] = 0;
    
//                     // Remove element from the DOM
//                     if (data.pageObjs[page])
//                         data.pageObjs[page].remove();
    
//                 }
    
//         },
    
//         // Checks if a page is in memory
        
//         hasPage: function(page) {
    
//             return page in this.data().pageObjs;
        
//         },
    
//         // Prepares the flip effect for a page
    
//         _makeFlip: function(page) {
    
//             var data = this.data();
    
//             if (!data.pages[page] && data.pagePlace[page]==page) {
    
//                 var single = data.display=='single',
//                     even = page%2;
                
//                 data.pages[page] = data.pageObjs[page].
//                                     css({width: (single) ? this.width() : this.width()/2, height: this.height()}).
//                                     flip({page: page,
//                                         next: (single && page === data.totalPages) ? page -1 : ((even || single) ? page+1 : page-1),
//                                         turn: this,
//                                         duration: data.opts.duration,
//                                         acceleration : data.opts.acceleration,
//                                         corners: (single) ? 'all' : ((even) ? 'forward' : 'backward'),
//                                         backGradient: data.opts.gradients,
//                                         frontGradient: data.opts.gradients
//                                         }).
//                                         flip('disable', data.disabled).
//                                         bind('pressed', turnMethods._pressed).
//                                         bind('released', turnMethods._released).
//                                         bind('start', turnMethods._start).
//                                         bind('end', turnMethods._end).
//                                         bind('flip', turnMethods._flip);
//             }
//             return data.pages[page];
//         },
    
//         // Makes pages within a range
    
//         _makeRange: function() {
    
//             var page,
//                 data = this.data(),
//                 range = this.turn('range');
    
//                 for (page = range[0]; page<=range[1]; page++)
//                     turnMethods._addPage.call(this, page);
    
//         },
    
//         // Returns a range of `pagesInDOM` pages that should be in the DOM
//         // Example:
//         // - page of the current view, return true
//         // * page is in the range, return true
//         // 0 page is not in the range, return false
//         //
//         // 1 2-3 4-5 6-7 8-9 10-11 12-13
//         //    **  **  --   **  **
    
//         range: function(page) {
    
//             var remainingPages, left, right,
//                 data = this.data();
//                 page = page || data.tpage || data.page;
//                 var view = turnMethods._view.call(this, page);
    
//                 if (page<1 || page>data.totalPages)
//                     throw new Error ('"'+page+'" is not a page for range');
            
//                 view[1] = view[1] || view[0];
                
//                 if (view[0]>=1 && view[1]<=data.totalPages) {
    
//                     remainingPages = Math.floor((pagesInDOM-2)/2);
    
//                     if (data.totalPages-view[1] > view[0]) {
//                         left = Math.min(view[0]-1, remainingPages);
//                         right = 2*remainingPages-left;
//                     } else {
//                         right = Math.min(data.totalPages-view[1], remainingPages);
//                         left = 2*remainingPages-right;
//                     }
    
//                 } else {
//                     left = pagesInDOM-1;
//                     right = pagesInDOM-1;
//                 }
    
//                 return [Math.max(1, view[0]-left), Math.min(data.totalPages, view[1]+right)];
    
//         },
    
//         // Detects if a page is within the range of `pagesInDOM` from the current view
    
//         _necessPage: function(page) {
            
//             if (page===0)
//                 return true;
    
//             var range = this.turn('range');
    
//             return page>=range[0] && page<=range[1];
            
//         },
    
//         // Releases memory by removing pages from the DOM
    
//         _removeFromDOM: function() {
    
//             var page, data = this.data();
    
//             for (page in data.pageWrap)
//                 if (has(page, data.pageWrap) && !turnMethods._necessPage.call(this, page))
//                     turnMethods._removePageFromDOM.call(this, page);
            
    
//         },
    
//         // Removes a page from DOM and its internal references
    
//         _removePageFromDOM: function(page) {
    
//             var data = this.data();
    
//             if (data.pages[page]) {
//                 var dd = data.pages[page].data();
//                 if (dd.f && dd.f.fwrapper)
//                     dd.f.fwrapper.remove();
//                 data.pages[page].remove();
//                 delete data.pages[page];
//             }
    
//             if (data.pageObjs[page])
//                 data.pageObjs[page].remove();
    
//             if (data.pageWrap[page]) {
//                 data.pageWrap[page].remove();
//                 delete data.pageWrap[page];
//             }
    
//             delete data.pagePlace[page];
    
//         },
    
//         // Removes a page
    
//         removePage: function(page) {
    
//             var data = this.data();
    
//             if (data.pageObjs[page]) {
//                 // Stop animations
//                 this.turn('stop');
    
//                 // Remove `page`
//                 turnMethods._removePageFromDOM.call(this, page);
//                 delete data.pageObjs[page];
    
//                 // Move the pages behind `page`
//                 turnMethods._movePages.call(this, page, -1);
    
//                 // Resize the size of this magazine
//                 data.totalPages = data.totalPages-1;
//                 turnMethods._makeRange.call(this);
    
//                 // Check the current view
//                 if (data.page>data.totalPages)
//                     this.turn('page', data.totalPages);
//             }
    
//             return this;
        
//         },
    
//         // Moves pages
    
//         _movePages: function(from, change) {
    
//             var page,
//                 data = this.data(),
//                 single = data.display=='single',
//                 move = function(page) {
    
//                     var next = page + change,
//                         odd = next%2;
    
//                     if (data.pageObjs[page])
//                         data.pageObjs[next] = data.pageObjs[page].removeClass('page' + page).addClass('page' + next);
    
//                     if (data.pagePlace[page] && data.pageWrap[page]) {
//                         data.pagePlace[next] = next;
//                         data.pageWrap[next] = data.pageWrap[page].css(pagePosition[(single) ? 0 : odd]).attr('page', next);
                        
//                         if (data.pages[page])
//                             data.pages[next] = data.pages[page].flip('options', {
//                                 page: next,
//                                 next: (single || odd) ? next+1 : next-1,
//                                 corners: (single) ? 'all' : ((odd) ? 'forward' : 'backward')
//                             });
    
//                         if (change) {
//                             delete data.pages[page];
//                             delete data.pagePlace[page];
//                             delete data.pageObjs[page];
//                             delete data.pageWrap[page];
//                             delete data.pageObjs[page];
//                         }
//                 }
//             };
    
//             if (change>0)
//                 for (page=data.totalPages; page>=from; page--) move(page);
//             else
//                 for (page=from; page<=data.totalPages; page++) move(page);
    
//         },
    
//         // Sets or Gets the display mode
    
//         display: function(display) {
    
//             var data = this.data(),
//                 currentDisplay = data.display;
    
//             if (display) {
    
//                 if ($.inArray(display, displays)==-1)
//                     throw new Error ('"'+display + '" is not a value for display');
                
//                 if (display=='single') {
//                     if (!data.pageObjs[0]) {
//                         this.turn('stop').
//                             css({'overflow': 'hidden'});
//                         data.pageObjs[0] = $('<div />', {'class': 'turn-page p-temporal'}).
//                                         css({width: this.width(), height: this.height()}).
//                                             appendTo(this);
//                     }
//                 } else {
//                     if (data.pageObjs[0]) {
//                         this.turn('stop').
//                             css({'overflow': ''});
//                         data.pageObjs[0].remove();
//                         delete data.pageObjs[0];
//                     }
//                 }
    
//                 data.display = display;
    
//                 if (currentDisplay) {
//                     var size = this.turn('size');
//                     turnMethods._movePages.call(this, 1, 0);
//                     this.turn('size', size.width, size.height).
//                             turn('update');
//                 }
    
//                 return this;
    
//             } else
//                 return currentDisplay;
        
//         },
    
//         // Detects if the pages are being animated
    
//         animating: function() {
    
//             return this.data().pageMv.length>0;
    
//         },
    
//         // Disables and enables the effect
    
//         disable: function(bool) {
    
//             var page,
//                 data = this.data(),
//                 view = this.turn('view');
    
//                 data.disabled = bool===undefined || bool===true;
    
//             for (page in data.pages)
//                 if (has(page, data.pages))
//                     data.pages[page].flip('disable', bool ? $.inArray(page, view) : false );
    
//             return this;
    
//         },
    
//         // Gets and sets the size
    
//         size: function(width, height) {
    
//             if (width && height) {
    
//                 var data = this.data(), pageWidth = (data.display=='double') ? width/2 : width, page;
    
//                 this.css({width: width, height: height});
    
//                 if (data.pageObjs[0])
//                     data.pageObjs[0].css({width: pageWidth, height: height});
                
//                 for (page in data.pageWrap) {
//                     if (!has(page, data.pageWrap)) continue;
//                     data.pageObjs[page].css({width: pageWidth, height: height});
//                     data.pageWrap[page].css({width: pageWidth, height: height});
//                     if (data.pages[page])
//                         data.pages[page].css({width: pageWidth, height: height});
//                 }
    
//                 this.turn('resize');
    
//                 return this;
    
//             } else {
                
//                 return {width: this.width(), height: this.height()};
    
//             }
//         },
    
//         // Resizes each page
    
//         resize: function() {
    
//             var page, data = this.data();
    
//             if (data.pages[0]) {
//                 data.pageWrap[0].css({left: -this.width()});
//                 data.pages[0].flip('resize', true);
//             }
    
//             for (page = 1; page <= data.totalPages; page++)
//                 if (data.pages[page])
//                     data.pages[page].flip('resize', true);
    
    
//         },
    
//         // Removes an animation from the cache
    
//         _removeMv: function(page) {
    
//             var i, data = this.data();
                
//             for (i=0; i<data.pageMv.length; i++)
//                 if (data.pageMv[i]==page) {
//                     data.pageMv.splice(i, 1);
//                     return true;
//                 }
    
//             return false;
    
//         },
    
//         // Adds an animation to the cache
        
//         _addMv: function(page) {
    
//             var data = this.data();
    
//             turnMethods._removeMv.call(this, page);
//             data.pageMv.push(page);
    
//         },
    
//         // Gets indexes for a view
    
//         _view: function(page) {
        
//             var data = this.data();
//             page = page || data.page;
    
//             if (data.display=='double')
//                 return (page%2) ? [page-1, page] : [page, page+1];
//             else
//                 return [page];
    
//         },
    
//         // Gets a view
    
//         view: function(page) {
    
//             var data = this.data(), view = turnMethods._view.call(this, page);
    
//             return (data.display=='double') ? [(view[0]>0) ? view[0] : 0, (view[1]<=data.totalPages) ? view[1] : 0]
//                     : [(view[0]>0 && view[0]<=data.totalPages) ? view[0] : 0];
    
//         },
    
//         // Stops animations
    
//         stop: function(ok) {
    
//             var i, opts, data = this.data(), pages = data.pageMv;
    
//             data.pageMv = [];
    
//             if (data.tpage) {
//                 data.page = data.tpage;
//                 delete data['tpage'];
//             }
    
//             for (i in pages) {
//                 if (!has(i, pages)) continue;
//                 opts = data.pages[pages[i]].data().f.opts;
//                 flipMethods._moveFoldingPage.call(data.pages[pages[i]], null);
//                 data.pages[pages[i]].flip('hideFoldedPage');
//                 data.pagePlace[opts.next] = opts.next;
                
//                 if (opts.force) {
//                     opts.next = (opts.page%2===0) ? opts.page-1 : opts.page+1;
//                     delete opts['force'];
//                 }
    
//             }
    
//             this.turn('update');
    
//             return this;
//         },
    
//         // Gets and sets the number of pages
    
//         pages: function(pages) {
    
//             var data = this.data();
    
//             if (pages) {
//                 if (pages<data.totalPages) {
    
//                     for (var page = pages+1; page<=data.totalPages; page++)
//                         this.turn('removePage', page);
    
//                     if (this.turn('page')>pages)
//                         this.turn('page', pages);
//                 }
    
//                 data.totalPages = pages;
    
//                 return this;
//             } else
//                 return data.totalPages;
    
//         },
    
//         // Sets a page without effect
    
//         _fitPage: function(page, ok) {
            
//             var data = this.data(), newView = this.turn('view', page);
            
//             if (data.page!=page) {
//                 this.trigger('turning', [page, newView]);
//                 if ($.inArray(1, newView)!=-1) this.trigger('first');
//                 if ($.inArray(data.totalPages, newView)!=-1) this.trigger('last');
//             }
    
//             if (!data.pageObjs[page])
//                 return;
    
//             data.tpage = page;
    
//             this.turn('stop', ok);
//             turnMethods._removeFromDOM.call(this);
//             turnMethods._makeRange.call(this);
//             this.trigger('turned', [page, newView]);
    
//         },
        
//         // Turns to a page
    
//         _turnPage: function(page) {
    
//             var current, next,
//                 data = this.data(),
//                 view = this.turn('view'),
//                 newView = this.turn('view', page);
        
//             if (data.page!=page) {
//                 this.trigger('turning', [page, newView]);
//                 if ($.inArray(1, newView)!=-1) this.trigger('first');
//                 if ($.inArray(data.totalPages, newView)!=-1) this.trigger('last');
//             }
    
//             if (!data.pageObjs[page])
//                 return;
    
//             data.tpage = page;
    
//             this.turn('stop');
    
//             turnMethods._makeRange.call(this);
    
//             if (data.display=='single') {
//                 current = view[0];
//                 next = newView[0];
//             } else if (view[1] && page>view[1]) {
//                 current = view[1];
//                 next = newView[0];
//             } else if (view[0] && page<view[0]) {
//                 current = view[0];
//                 next = newView[1];
//             }
    
//             if (data.pages[current]) {
    
//                 var opts = data.pages[current].data().f.opts;
//                 data.tpage = next;
                
//                 if (opts.next!=next) {
//                     opts.next = next;
//                     data.pagePlace[next] = opts.page;
//                     opts.force = true;
//                 }
    
//                 if (data.display=='single')
//                     data.pages[current].flip('turnPage', (newView[0] > view[0]) ? 'br' : 'bl');
//                 else
//                     data.pages[current].flip('turnPage');
//             }
    
//         },
    
//         // Gets and sets a page
    
//         page: function(page) {
    
//             page = parseInt(page, 10);
    
//             var data = this.data();
    
//             if (page>0 && page<=data.totalPages) {
//                 if (!data.done || $.inArray(page, this.turn('view'))!=-1)
//                     turnMethods._fitPage.call(this, page);
//                 else
//                     turnMethods._turnPage.call(this, page);
            
//                 return this;
    
//             } else
//                 return data.page;
        
//         },
    
//         // Turns to the next view
    
//         next: function() {
    
//             var data = this.data();
//             return this.turn('page', turnMethods._view.call(this, data.page).pop() + 1);
        
//         },
    
//         // Turns to the previous view
    
//         previous: function() {
            
//             var data = this.data();
//             return this.turn('page', turnMethods._view.call(this, data.page).shift() - 1);
    
//         },
    
//         // Adds a motion to the internal list
    
//         _addMotionPage: function() {
    
//             var opts = $(this).data().f.opts,
//                 turn = opts.turn,
//                 dd = turn.data();
    
//             opts.pageMv = opts.page;
//             turnMethods._addMv.call(turn, opts.pageMv);
//             dd.pagePlace[opts.next] = opts.page;
//             turn.turn('update');
    
//         },
    
//         // This event is called in context of flip
    
//         _start: function(e, opts, corner) {
    
//                 var data = opts.turn.data(),
//                     event = $.Event('start');
    
//                 e.stopPropagation();
    
//                 opts.turn.trigger(event, [opts, corner]);
    
//                 if (event.isDefaultPrevented()) {
//                     e.preventDefault();
//                     return;
//                 }
            
//             if (data.display=='single') {
    
//                 var left = corner.charAt(1)=='l';
//                 if ((opts.page==1 && left) || (opts.page==data.totalPages && !left))
//                     e.preventDefault();
//                 else {
//                     if (left) {
//                         opts.next = (opts.next<opts.page) ? opts.next : opts.page-1;
//                         opts.force = true;
//                     } else
//                         opts.next = (opts.next>opts.page) ? opts.next : opts.page+1;
//                 }
    
//             }
    
//             turnMethods._addMotionPage.call(this);
//         },
    
//         // This event is called in context of flip
    
//         _end: function(e, turned) {
            
//             var that = $(this),
//                 data = that.data().f,
//                 opts = data.opts,
//                 turn = opts.turn,
//                 dd = turn.data();
    
//             e.stopPropagation();
    
//             if (turned || dd.tpage) {
    
//                 if (dd.tpage==opts.next || dd.tpage==opts.page) {
//                     delete dd['tpage'];
//                     turnMethods._fitPage.call(turn, dd.tpage || opts.next, true);
//                 }
    
//             } else {
//                 turnMethods._removeMv.call(turn, opts.pageMv);
//                 turn.turn('update');
//             }
            
//         },
        
//         // This event is called in context of flip
    
//         _pressed: function() {
    
//             var page,
//                 that = $(this),
//                 data = that.data().f,
//                 turn = data.opts.turn,
//                 pages = turn.data().pages;
        
//             for (page in pages)
//                 if (page!=data.opts.page)
//                     pages[page].flip('disable', true);
    
//             return data.time = new Date().getTime();
    
//         },
    
//         // This event is called in context of flip
    
//         _released: function(e, point) {
            
//             var that = $(this),
//                 data = that.data().f;
    
//                 e.stopPropagation();
    
//             if ((new Date().getTime())-data.time<200 || point.x<0 || point.x>$(this).width()) {
//                 e.preventDefault();
//                 data.opts.turn.data().tpage = data.opts.next;
//                 data.opts.turn.turn('update');
//                 $(that).flip('turnPage');
//             }
    
//         },
    
//         // This event is called in context of flip
        
//         _flip: function() {
    
//             var opts = $(this).data().f.opts;
    
//             opts.turn.trigger('turn', [opts.next]);
    
//         },
    
//         // Calculate the z-index value for pages during the animation
    
//         calculateZ: function(mv) {
    
//             var i, page, nextPage, placePage, dpage,
//                 that = this,
//                 data = this.data(),
//                 view = this.turn('view'),
//                 currentPage = view[0] || view[1],
//                 r = {pageZ: {}, partZ: {}, pageV: {}},
    
//                 addView = function(page) {
//                     var view = that.turn('view', page);
//                     if (view[0]) r.pageV[view[0]] = true;
//                     if (view[1]) r.pageV[view[1]] = true;
//                 };
            
//                 for (i = 0; i<mv.length; i++) {
//                     page = mv[i];
//                     nextPage = data.pages[page].data().f.opts.next;
//                     placePage = data.pagePlace[page];
//                     addView(page);
//                     addView(nextPage);
//                     dpage = (data.pagePlace[nextPage]==nextPage) ? nextPage : page;
//                     r.pageZ[dpage] = data.totalPages - Math.abs(currentPage-dpage);
//                     r.partZ[placePage] = data.totalPages*2 + Math.abs(currentPage-dpage);
//                 }
    
//             return r;
//         },
    
//         // Updates the z-index and display property of every page
    
//         update: function() {
    
//             var page,
//                 data = this.data();
    
//             if (data.pageMv.length && data.pageMv[0]!==0) {
    
//                 // Update motion
    
//                 var apage,
//                     pos = this.turn('calculateZ', data.pageMv),
//                     view = this.turn('view', data.tpage);
            
//                 if (data.pagePlace[view[0]]==view[0]) apage = view[0];
//                 else if (data.pagePlace[view[1]]==view[1]) apage = view[1];
            
//                 for (page in data.pageWrap) {
    
//                     if (!has(page, data.pageWrap)) continue;
    
//                     data.pageWrap[page].css({display: (pos.pageV[page]) ? '' : 'none', 'z-index': pos.pageZ[page] || 0});
    
//                     if (data.pages[page]) {
//                         data.pages[page].flip('z', pos.partZ[page] || null);
    
//                         if (pos.pageV[page])
//                             data.pages[page].flip('resize');
    
//                         if (data.tpage)
//                             data.pages[page].flip('disable', true); // data.disabled || page!=apage
//                     }
//                 }
                    
//             } else {
    
//                 // Update static pages
    
//                 for (page in data.pageWrap) {
//                     if (!has(page, data.pageWrap)) continue;
//                         var pageLocation = turnMethods._setPageLoc.call(this, page);
//                         if (data.pages[page])
//                             data.pages[page].flip('disable', data.disabled || pageLocation!=1).flip('z', null);
//                 }
//             }
//         },
    
//         // Sets the z-index and display property of a page
//         // It depends on the current view
    
//         _setPageLoc: function(page) {
    
//             var data = this.data(),
//                 view = this.turn('view');
    
//             if (page==view[0] || page==view[1]) {
//                 data.pageWrap[page].css({'z-index': data.totalPages, display: ''});
//                 return 1;
//             } else if ((data.display=='single' && page==view[0]+1) || (data.display=='double' && page==view[0]-2 || page==view[1]+2)) {
//                 data.pageWrap[page].css({'z-index': data.totalPages-1, display: ''});
//                 return 2;
//             } else {
//                 data.pageWrap[page].css({'z-index': 0, display: 'none'});
//                 return 0;
//             }
//         }
//     },
    
//     // Methods and properties for the flip page effect
    
//     flipMethods = {
    
//         // Constructor
    
//         init: function(opts) {
    
//             if (opts.gradients) {
//                 opts.frontGradient = true;
//                 opts.backGradient = true;
//             }
    
//             this.data({f: {}});
//             this.flip('options', opts);
    
//             flipMethods._addPageWrapper.call(this);
    
//             return this;
//         },
    
//         setData: function(d) {
            
//             var data = this.data();
    
//             data.f = $.extend(data.f, d);
    
//             return this;
//         },
    
//         options: function(opts) {
            
//             var data = this.data().f;
    
//             if (opts) {
//                 flipMethods.setData.call(this, {opts: $.extend({}, data.opts || flipOptions, opts) });
//                 return this;
//             } else
//                 return data.opts;
    
//         },
    
//         z: function(z) {
    
//             var data = this.data().f;
//             data.opts['z-index'] = z;
//             data.fwrapper.css({'z-index': z || parseInt(data.parent.css('z-index'), 10) || 0});
    
//             return this;
//         },
    
//         _cAllowed: function() {
    
//             return corners[this.data().f.opts.corners] || this.data().f.opts.corners;
    
//         },
    
//         _cornerActivated: function(e) {
//             if (e.originalEvent === undefined) {
//                 return false;
//             }		
    
//             e = (isTouch) ? e.originalEvent.touches : [e];
    
//             var data = this.data().f,
//                 pos = data.parent.offset(),
//                 width = this.width(),
//                 height = this.height(),
//                 c = {x: Math.max(0, e[0].pageX-pos.left), y: Math.max(0, e[0].pageY-pos.top)},
//                 csz = data.opts.cornerSize,
//                 allowedCorners = flipMethods._cAllowed.call(this);
    
//                 if (c.x<=0 || c.y<=0 || c.x>=width || c.y>=height) return false;
    
//                 if (c.y<csz) c.corner = 't';
//                 else if (c.y>=height-csz) c.corner = 'b';
//                 else return false;
                
//                 if (c.x<=csz) c.corner+= 'l';
//                 else if (c.x>=width-csz) c.corner+= 'r';
//                 else return false;
    
//             return ($.inArray(c.corner, allowedCorners)==-1) ? false : c;
    
//         },
    
//         _c: function(corner, opts) {
    
//             opts = opts || 0;
//             return ({tl: point2D(opts, opts),
//                     tr: point2D(this.width()-opts, opts),
//                     bl: point2D(opts, this.height()-opts),
//                     br: point2D(this.width()-opts, this.height()-opts)})[corner];
    
//         },
    
//         _c2: function(corner) {
    
//             return {tl: point2D(this.width()*2, 0),
//                     tr: point2D(-this.width(), 0),
//                     bl: point2D(this.width()*2, this.height()),
//                     br: point2D(-this.width(), this.height())}[corner];
    
//         },
    
//         _foldingPage: function(corner) {
    
//             var opts = this.data().f.opts;
            
//             if (opts.folding) return opts.folding;
//             else if(opts.turn) {
//                 var data = opts.turn.data();
//                 if (data.display == 'single')
//                     return (data.pageObjs[opts.next]) ? data.pageObjs[0] : null;
//                 else
//                     return data.pageObjs[opts.next];
//             }
    
//         },
    
//         _backGradient: function() {
    
//             var data =	this.data().f,
//                 turn = data.opts.turn,
//                 gradient = data.opts.backGradient &&
//                             (!turn || turn.data().display=='single' || (data.opts.page!=2 && data.opts.page!=turn.data().totalPages-1) );
    
    
//             if (gradient && !data.bshadow)
//                 data.bshadow = $('<div/>', divAtt(0, 0, 1)).
//                     css({'position': '', width: this.width(), height: this.height()}).
//                         appendTo(data.parent);
    
//             return gradient;
    
//         },
    
//         resize: function(full) {
            
//             var data = this.data().f,
//                 width = this.width(),
//                 height = this.height(),
//                 size = Math.round(Math.sqrt(Math.pow(width, 2)+Math.pow(height, 2)));
    
//             if (full) {
//                 data.wrapper.css({width: size, height: size});
//                 data.fwrapper.css({width: size, height: size}).
//                     children(':first-child').
//                         css({width: width, height: height});
    
//                 data.fpage.css({width: height, height: width});
    
//                 if (data.opts.frontGradient)
//                     data.ashadow.css({width: height, height: width});
    
//                 if (flipMethods._backGradient.call(this))
//                     data.bshadow.css({width: width, height: height});
//             }
    
//             if (data.parent.is(':visible')) {
//                 data.fwrapper.css({top: data.parent.offset().top,
//                     left: data.parent.offset().left});
    
//                 if (data.opts.turn)
//                     data.fparent.css({top: -data.opts.turn.offset().top, left: -data.opts.turn.offset().left});
//             }
    
//             this.flip('z', data.opts['z-index']);
    
//         },
    
//         // Prepares the page by adding a general wrapper and another objects
    
//         _addPageWrapper: function() {
    
//             var att,
//                 data = this.data().f,
//                 parent = this.parent();
    
//             if (!data.wrapper) {
    
//                 var left = this.css('left'),
//                     top = this.css('top'),
//                     width = this.width(),
//                     height = this.height(),
//                     size = Math.round(Math.sqrt(Math.pow(width, 2)+Math.pow(height, 2)));
                
//                 data.parent = parent;
//                 data.fparent = (data.opts.turn) ? data.opts.turn.data().fparent : $('#turn-fwrappers');
    
//                 if (!data.fparent) {
//                     var fparent = $('<div/>', {css: {'pointer-events': 'none'}}).hide();
//                         fparent.data().flips = 0;
    
//                     if (data.opts.turn) {
//                         fparent.css(divAtt(-data.opts.turn.offset().top, -data.opts.turn.offset().left, 'auto', 'visible').css).
//                                 appendTo(data.opts.turn);
                        
//                         data.opts.turn.data().fparent = fparent;
//                     } else {
//                         fparent.css(divAtt(0, 0, 'auto', 'visible').css).
//                             attr('id', 'turn-fwrappers').
//                                 appendTo($('body'));
//                     }
    
//                     data.fparent = fparent;
//                 }
    
//                 this.css({position: 'absolute', top: 0, left: 0, bottom: 'auto', right: 'auto'});
    
//                 data.wrapper = $('<div/>', divAtt(0, 0, this.css('z-index'))).
//                                     appendTo(parent).
//                                         prepend(this);
    
//                 data.fwrapper = $('<div/>', divAtt(parent.offset().top, parent.offset().left)).
//                                     hide().
//                                         appendTo(data.fparent);
    
//                 data.fpage = $('<div/>', {css: {cursor: 'default'}}).
//                         appendTo($('<div/>', divAtt(0, 0, 0, 'visible')).
//                                     appendTo(data.fwrapper));
    
//                 if (data.opts.frontGradient)
//                     data.ashadow = $('<div/>', divAtt(0, 0,  1)).
//                         appendTo(data.fpage);
    
//                 // Save data
    
//                 flipMethods.setData.call(this, data);
    
//                 // Set size
//                 flipMethods.resize.call(this, true);
//             }
    
//         },
    
//         // Takes a 2P point from the screen and applies the transformation
    
//         _fold: function(point) {
    
//             var that = this,
//                 a = 0,
//                 alpha = 0,
//                 beta,
//                 px,
//                 gradientEndPointA,
//                 gradientEndPointB,
//                 gradientStartV,
//                 gradientSize,
//                 gradientOpacity,
//                 mv = point2D(0, 0),
//                 df = point2D(0, 0),
//                 tr = point2D(0, 0),
//                 width = this.width(),
//                 height = this.height(),
//                 folding = flipMethods._foldingPage.call(this),
//                 tan = Math.tan(alpha),
//                 data = this.data().f,
//                 ac = data.opts.acceleration,
//                 h = data.wrapper.height(),
//                 o = flipMethods._c.call(this, point.corner),
//                 top = point.corner.substr(0, 1) == 't',
//                 left = point.corner.substr(1, 1) == 'l',
    
//                 compute = function() {
//                     var rel = point2D((o.x) ? o.x - point.x : point.x, (o.y) ? o.y - point.y : point.y),
//                         tan = (Math.atan2(rel.y, rel.x)),
//                         middle;
    
//                     alpha = A90 - tan;
//                     a = deg(alpha);
//                     middle = point2D((left) ? width - rel.x/2 : point.x + rel.x/2, rel.y/2);
    
//                     var gamma = alpha - Math.atan2(middle.y, middle.x),
//                         distance =  Math.max(0, Math.sin(gamma) * Math.sqrt(Math.pow(middle.x, 2) + Math.pow(middle.y, 2)));
    
//                         tr = point2D(distance * Math.sin(alpha), distance * Math.cos(alpha));
    
//                         if (alpha > A90) {
                        
//                             tr.x = tr.x + Math.abs(tr.y * Math.tan(tan));
//                             tr.y = 0;
    
//                             if (Math.round(tr.x*Math.tan(PI-alpha)) < height) {
    
//                                 point.y = Math.sqrt(Math.pow(height, 2)+2 * middle.x * rel.x);
//                                 if (top) point.y =  height - point.y;
//                                 return compute();
    
//                             }
//                         }
                
//                     if (alpha>A90) {
//                         var beta = PI-alpha, dd = h - height/Math.sin(beta);
//                         mv = point2D(Math.round(dd*Math.cos(beta)), Math.round(dd*Math.sin(beta)));
//                         if (left) mv.x = - mv.x;
//                         if (top) mv.y = - mv.y;
//                     }
    
//                     px = Math.round(tr.y/Math.tan(alpha) + tr.x);
                
//                     var side = width - px,
//                         sideX = side*Math.cos(alpha*2),
//                         sideY = side*Math.sin(alpha*2);
//                         df = point2D(Math.round( (left ? side -sideX : px+sideX)), Math.round((top) ? sideY : height - sideY));
                        
                    
//                     // GRADIENTS
    
//                         gradientSize = side*Math.sin(alpha);
//                             var endingPoint = flipMethods._c2.call(that, point.corner),
//                             far = Math.sqrt(Math.pow(endingPoint.x-point.x, 2)+Math.pow(endingPoint.y-point.y, 2));
    
//                         gradientOpacity = (far<width) ? far/width : 1;
    
    
//                     if (data.opts.frontGradient) {
    
//                         gradientStartV = gradientSize>100 ? (gradientSize-100)/gradientSize : 0;
//                         gradientEndPointA = point2D(gradientSize*Math.sin(A90-alpha)/height*100, gradientSize*Math.cos(A90-alpha)/width*100);
                    
//                         if (top) gradientEndPointA.y = 100-gradientEndPointA.y;
//                         if (left) gradientEndPointA.x = 100-gradientEndPointA.x;
//                     }
    
//                     if (flipMethods._backGradient.call(that)) {
    
//                         gradientEndPointB = point2D(gradientSize*Math.sin(alpha)/width*100, gradientSize*Math.cos(alpha)/height*100);
//                         if (!left) gradientEndPointB.x = 100-gradientEndPointB.x;
//                         if (!top) gradientEndPointB.y = 100-gradientEndPointB.y;
//                     }
//                     //
    
//                     tr.x = Math.round(tr.x);
//                     tr.y = Math.round(tr.y);
    
//                     return true;
//                 },
    
//                 transform = function(tr, c, x, a) {
                
//                     var f = ['0', 'auto'], mvW = (width-h)*x[0]/100, mvH = (height-h)*x[1]/100,
//                         v = {left: f[c[0]], top: f[c[1]], right: f[c[2]], bottom: f[c[3]]},
//                         aliasingFk = (a!=90 && a!=-90) ? (left ? -1 : 1) : 0;
    
//                         x = x[0] + '% ' + x[1] + '%';
    
//                     that.css(v).transform(rotate(a) + translate(tr.x + aliasingFk, tr.y, ac), x);
    
//                     data.fpage.parent().css(v);
//                     data.wrapper.transform(translate(-tr.x + mvW-aliasingFk, -tr.y + mvH, ac) + rotate(-a), x);
    
//                     data.fwrapper.transform(translate(-tr.x + mv.x + mvW, -tr.y + mv.y + mvH, ac) + rotate(-a), x);
//                     data.fpage.parent().transform(rotate(a) + translate(tr.x + df.x - mv.x, tr.y + df.y - mv.y, ac), x);
    
//                     if (data.opts.frontGradient)
//                         gradient(data.ashadow,
//                                 point2D(left?100:0, top?100:0),
//                                 point2D(gradientEndPointA.x, gradientEndPointA.y),
//                                 [[gradientStartV, 'rgba(0,0,0,0)'],
//                                 [((1-gradientStartV)*0.8)+gradientStartV, 'rgba(0,0,0,'+(0.2*gradientOpacity)+')'],
//                                 [1, 'rgba(255,255,255,'+(0.2*gradientOpacity)+')']],
//                                 3,
//                                 alpha);
            
//                     if (flipMethods._backGradient.call(that))
//                         gradient(data.bshadow,
//                                 point2D(left?0:100, top?0:100),
//                                 point2D(gradientEndPointB.x, gradientEndPointB.y),
//                                 [[0.8, 'rgba(0,0,0,0)'],
//                                 [1, 'rgba(0,0,0,'+(0.3*gradientOpacity)+')'],
//                                 [1, 'rgba(0,0,0,0)']],
//                                 3);
                    
//                 };
    
//             switch (point.corner) {
//                 case 'tl' :
//                     point.x = Math.max(point.x, 1);
//                     compute();
//                     transform(tr, [1,0,0,1], [100, 0], a);
//                     data.fpage.transform(translate(-height, -width, ac) + rotate(90-a*2) , '100% 100%');
//                     folding.transform(rotate(90) + translate(0, -height, ac), '0% 0%');
//                 break;
//                 case 'tr' :
//                     point.x = Math.min(point.x, width-1);
//                     compute();
//                     transform(point2D(-tr.x, tr.y), [0,0,0,1], [0, 0], -a);
//                     data.fpage.transform(translate(0, -width, ac) + rotate(-90+a*2) , '0% 100%');
//                     folding.transform(rotate(270) + translate(-width, 0, ac), '0% 0%');
//                 break;
//                 case 'bl' :
//                     point.x = Math.max(point.x, 1);
//                     compute();
//                     transform(point2D(tr.x, -tr.y), [1,1,0,0], [100, 100], -a);
//                     data.fpage.transform(translate(-height, 0, ac) + rotate(-90+a*2), '100% 0%');
//                     folding.transform(rotate(270) + translate(-width, 0, ac), '0% 0%');
//                 break;
//                 case 'br' :
//                     point.x = Math.min(point.x, width-1);
//                     compute();
//                     transform(point2D(-tr.x, -tr.y), [0,1,1,0], [0, 100], a);
//                     data.fpage.transform(rotate(90-a*2), '0% 0%');
//                     folding.transform(rotate(90) + translate(0, -height, ac), '0% 0%');
    
//                 break;
//             }
    
//             data.point = point;
        
//         },
    
//         _moveFoldingPage: function(bool) {
    
//             var data = this.data().f,
//                 folding = flipMethods._foldingPage.call(this);
    
//             if (folding) {
//                 if (bool) {
//                     if (!data.fpage.children()[data.ashadow? '1' : '0']) {
//                         flipMethods.setData.call(this, {backParent: folding.parent()});
//                         data.fpage.prepend(folding);
//                     }
//                 } else {
//                     if (data.backParent)
//                         data.backParent.prepend(folding);
    
//                 }
//             }
    
//         },
    
//         _showFoldedPage: function(c, animate) {
    
//             var folding = flipMethods._foldingPage.call(this),
//                 dd = this.data(),
//                 data = dd.f;
    
//             if (!data.point || data.point.corner!=c.corner) {
//                 var event = $.Event('start');
//                 this.trigger(event, [data.opts, c.corner]);
    
//                 if (event.isDefaultPrevented())
//                     return false;
//             }
    
    
//             if (folding) {
    
//                 if (animate) {
    
//                     var that = this, point = (data.point && data.point.corner==c.corner) ? data.point : flipMethods._c.call(this, c.corner, 1);
                
//                     this.animatef({from: [point.x, point.y], to:[c.x, c.y], duration: 500, frame: function(v) {
//                         c.x = Math.round(v[0]);
//                         c.y = Math.round(v[1]);
//                         flipMethods._fold.call(that, c);
//                     }});
    
//                 } else	{
    
//                     flipMethods._fold.call(this, c);
//                     if (dd.effect && !dd.effect.turning)
//                         this.animatef(false);
    
//                 }
    
//                 if (!data.fwrapper.is(':visible')) {
//                     data.fparent.show().data().flips++;
//                     flipMethods._moveFoldingPage.call(this, true);
//                     data.fwrapper.show();
    
//                     if (data.bshadow)
//                         data.bshadow.show();
//                 }
    
//                 return true;
//             }
    
//             return false;
//         },
    
//         hide: function() {
    
//             var data = this.data().f,
//                 folding = flipMethods._foldingPage.call(this);
    
//             if ((--data.fparent.data().flips)===0)
//                 data.fparent.hide();
    
//             this.css({left: 0, top: 0, right: 'auto', bottom: 'auto'}).transform('', '0% 100%');
    
//             data.wrapper.transform('', '0% 100%');
    
//             data.fwrapper.hide();
    
//             if (data.bshadow)
//                 data.bshadow.hide();
    
//             folding.transform('', '0% 0%');
    
//             return this;
//         },
    
//         hideFoldedPage: function(animate) {
    
//             var data = this.data().f;
    
//             if (!data.point) return;
    
//             var that = this,
//                 p1 = data.point,
//                 hide = function() {
//                     data.point = null;
//                     that.flip('hide');
//                     that.trigger('end', [false]);
//                 };
    
//             if (animate) {
//                 var p4 = flipMethods._c.call(this, p1.corner),
//                     top = (p1.corner.substr(0,1)=='t'),
//                     delta = (top) ? Math.min(0, p1.y-p4.y)/2 : Math.max(0, p1.y-p4.y)/2,
//                     p2 = point2D(p1.x, p1.y+delta),
//                     p3 = point2D(p4.x, p4.y-delta);
            
//                 this.animatef({
//                     from: 0,
//                     to: 1,
//                     frame: function(v) {
//                         var np = bezier(p1, p2, p3, p4, v);
//                         p1.x = np.x;
//                         p1.y = np.y;
//                         flipMethods._fold.call(that, p1);
//                     },
//                     complete: hide,
//                     duration: 800,
//                     hiding: true
//                     });
    
//             } else {
//                 this.animatef(false);
//                 hide();
//             }
//         },
    
//         turnPage: function(corner) {
    
//             var that = this,
//                 data = this.data().f;
    
//             corner = {corner: (data.corner) ? data.corner.corner : corner || flipMethods._cAllowed.call(this)[0]};
    
//             var p1 = data.point || flipMethods._c.call(this, corner.corner, (data.opts.turn) ? data.opts.turn.data().opts.elevation : 0),
//                 p4 = flipMethods._c2.call(this, corner.corner);
    
//                 this.trigger('flip').
//                     animatef({
//                         from: 0,
//                         to: 1,
//                         frame: function(v) {
//                             var np = bezier(p1, p1, p4, p4, v);
//                             corner.x = np.x;
//                             corner.y = np.y;
//                             flipMethods._showFoldedPage.call(that, corner);
//                         },
                        
//                         complete: function() {
//                             that.trigger('end', [true]);
//                         },
//                         duration: data.opts.duration,
//                         turning: true
//                     });
    
//                 data.corner = null;
//         },
    
//         moving: function() {
    
//             return 'effect' in this.data();
        
//         },
    
//         isTurning: function() {
    
//             return this.flip('moving') && this.data().effect.turning;
        
//         },
    
//         _eventStart: function(e) {
    
//             var data = this.data().f;
    
//             if (!data.disabled && !this.flip('isTurning')) {
//                 data.corner = flipMethods._cornerActivated.call(this, e);
//                 if (data.corner && flipMethods._foldingPage.call(this, data.corner)) {
//                     flipMethods._moveFoldingPage.call(this, true);
//                     this.trigger('pressed', [data.point]);
//                     return false;
//                 } else
//                     data.corner = null;
//             }
    
//         },
    
//         _eventMove: function(e) {
    
//             var data = this.data().f;
    
//             if (!data.disabled) {
//                 e = (isTouch) ? e.originalEvent.touches : [e];
            
//                 if (data.corner) {
    
//                     var pos = data.parent.offset();
    
//                     data.corner.x = e[0].pageX-pos.left;
//                     data.corner.y = e[0].pageY-pos.top;
    
//                     flipMethods._showFoldedPage.call(this, data.corner);
                
//                 } else if (!this.data().effect && this.is(':visible')) { // roll over
                    
//                     var corner = flipMethods._cornerActivated.call(this, e[0]);
//                     if (corner) {
//                         var origin = flipMethods._c.call(this, corner.corner, data.opts.cornerSize/2);
//                         corner.x = origin.x;
//                         corner.y = origin.y;
//                         flipMethods._showFoldedPage.call(this, corner, true);
//                     } else
//                         flipMethods.hideFoldedPage.call(this, true);
    
//                 }
//             }
//         },
    
//         _eventEnd: function() {
    
//             var data = this.data().f;
    
//             if (!data.disabled && data.point) {
//                 var event = $.Event('released');
//                 this.trigger(event, [data.point]);
//                 if (!event.isDefaultPrevented())
//                     flipMethods.hideFoldedPage.call(this, true);
//             }
    
//             data.corner = null;
    
//         },
    
//         disable: function(disable) {
    
//             flipMethods.setData.call(this, {'disabled': disable});
//             return this;
    
//         }
//     },
    
//     cla = function(that, methods, args) {
    
//         if (!args[0] || typeof(args[0])=='object')
//             return methods.init.apply(that, args);
//         else if(methods[args[0]] && args[0].toString().substr(0, 1)!='_')
//             return methods[args[0]].apply(that, Array.prototype.slice.call(args, 1));
//         else
//             throw args[0] + ' is an invalid value';
//     };
    
//     $.extend($.fn, {
    
//         flip: function(req, opts) {
//             return cla(this, flipMethods, arguments);
//         },
    
//         turn: function(req) {
//             return cla(this, turnMethods, arguments);
//         },
    
//         transform: function(transform, origin) {
    
//             var properties = {};
            
//             if (origin)
//                 properties[vendor+'transform-origin'] = origin;
            
//             properties[vendor+'transform'] = transform;
        
//             return this.css(properties);
    
//         },
    
//         animatef: function(point) {
    
//             var data = this.data();
    
//             if (data.effect)
//                 clearInterval(data.effect.handle);
    
//             if (point) {
    
//                 if (!point.to.length) point.to = [point.to];
//                 if (!point.from.length) point.from = [point.from];
//                 if (!point.easing) point.easing = function (x, t, b, c, data) { return c * Math.sqrt(1 - (t=t/data-1)*t) + b; };
    
//                 var j, diff = [],
//                     len = point.to.length,
//                     that = this,
//                     fps = point.fps || 30,
//                     time = - fps,
//                     f = function() {
//                         var j, v = [];
//                         time = Math.min(point.duration, time + fps);
        
//                         for (j = 0; j < len; j++)
//                             v.push(point.easing(1, time, point.from[j], diff[j], point.duration));
    
//                         point.frame((len==1) ? v[0] : v);
    
//                         if (time==point.duration) {
//                             clearInterval(data.effect.handle);
//                             delete data['effect'];
//                             that.data(data);
//                             if (point.complete)
//                                 point.complete();
//                             }
//                         };
    
//                 for (j = 0; j < len; j++)
//                     diff.push(point.to[j] - point.from[j]);
    
//                 data.effect = point;
//                 data.effect.handle = setInterval(f, fps);
//                 this.data(data);
//                 f();
//             } else {
//                 delete data['effect'];
//             }
//         }
//     });
    
    
//     $.isTouch = isTouch;
    
//     })(jQuery);


/**
 * Skipped minification because the original files appears to be already minified.
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
!(function (t, e) {
    "object" == typeof exports && "undefined" != typeof module ? e(exports) : "function" == typeof define && define.amd ? define(["exports"], e) : e(((t = t || self).St = {}));
})(this, function (t) {
    "use strict";
    class e {
        constructor(t, e) {
            (this.state = { angle: 0, area: [], position: { x: 0, y: 0 }, hardAngle: 0, hardDrawingAngle: 0 }), (this.createdDensity = e), (this.nowDrawingDensity = this.createdDensity), (this.render = t);
        }
        setDensity(t) {
            (this.createdDensity = t), (this.nowDrawingDensity = t);
        }
        setDrawingDensity(t) {
            this.nowDrawingDensity = t;
        }
        setPosition(t) {
            this.state.position = t;
        }
        setAngle(t) {
            this.state.angle = t;
        }
        setArea(t) {
            this.state.area = t;
        }
        setHardDrawingAngle(t) {
            this.state.hardDrawingAngle = t;
        }
        setHardAngle(t) {
            (this.state.hardAngle = t), (this.state.hardDrawingAngle = t);
        }
        setOrientation(t) {
            this.orientation = t;
        }
        getDrawingDensity() {
            return this.nowDrawingDensity;
        }
        getDensity() {
            return this.createdDensity;
        }
        getHardAngle() {
            return this.state.hardAngle;
        }
    }
    class i extends e {
        constructor(t, e, i) {
            super(t, i), (this.image = null), (this.isLoad = !1), (this.loadingAngle = 0), (this.image = new Image()), (this.image.src = e);
        }
        draw(t) {
            const e = this.render.getContext(),
                i = this.render.convertToGlobal(this.state.position),
                s = this.render.getRect().pageWidth,
                n = this.render.getRect().height;
            e.save(), e.translate(i.x, i.y), e.beginPath();
            for (let t of this.state.area) null !== t && ((t = this.render.convertToGlobal(t)), e.lineTo(t.x - i.x, t.y - i.y));
            e.rotate(this.state.angle), e.clip(), this.isLoad ? e.drawImage(this.image, 0, 0, s, n) : this.drawLoader(e, { x: 0, y: 0 }, s, n), e.restore();
        }
        simpleDraw(t) {
            const e = this.render.getRect(),
                i = this.render.getContext(),
                s = e.pageWidth,
                n = e.height,
                h = 1 === t ? e.left + e.pageWidth : e.left,
                r = e.top;
            this.isLoad ? i.drawImage(this.image, h, r, s, n) : this.drawLoader(i, { x: h, y: r }, s, n);
        }
        drawLoader(t, e, i, s) {
            t.beginPath(), (t.strokeStyle = "rgb(200, 200, 200)"), (t.fillStyle = "rgb(255, 255, 255)"), (t.lineWidth = 1), t.rect(e.x + 1, e.y + 1, i - 1, s - 1), t.stroke(), t.fill();
            const n = { x: e.x + i / 2, y: e.y + s / 2 };
            t.beginPath(),
                (t.lineWidth = 10),
                t.arc(n.x, n.y, 20, this.loadingAngle, (3 * Math.PI) / 2 + this.loadingAngle),
                t.stroke(),
                t.closePath(),
                (this.loadingAngle += 0.07),
                this.loadingAngle >= 2 * Math.PI && (this.loadingAngle = 0);
        }
        load() {
            this.isLoad ||
                (this.image.onload = () => {
                    this.isLoad = !0;
                });
        }
        newTemporaryCopy() {
            return this;
        }
        getTemporaryCopy() {
            return this;
        }
        hideTemporaryCopy() {}
    }
    class s {
        constructor(t, e) {
            (this.pages = []),
                (this.currentPageIndex = 0),
                (this.currentSpreadIndex = 0),
                (this.landscapeSpread = []),
                (this.portraitSpread = []),
                (this.render = e),
                (this.app = t),
                (this.currentPageIndex = 0),
                (this.isShowCover = this.app.getSettings().showCover);
        }
        destroy() {
            this.pages = [];
        }
        createSpread() {
            (this.landscapeSpread = []), (this.portraitSpread = []);
            for (let t = 0; t < this.pages.length; t++) this.portraitSpread.push([t]);
            let t = 0;
            this.isShowCover && (this.pages[0].setDensity("hard"), this.landscapeSpread.push([t]), t++);
            for (let e = t; e < this.pages.length; e += 2) e < this.pages.length - 1 ? this.landscapeSpread.push([e, e + 1]) : (this.landscapeSpread.push([e]), this.pages[e].setDensity("hard"));
        }
        getSpread() {
            return "landscape" === this.render.getOrientation() ? this.landscapeSpread : this.portraitSpread;
        }
        getSpreadIndexByPage(t) {
            const e = this.getSpread();
            for (let i = 0; i < e.length; i++) if (t === e[i][0] || t === e[i][1]) return i;
            return null;
        }
        getPageCount() {
            return this.pages.length;
        }
        getPages() {
            return this.pages;
        }
        getPage(t) {
            if (t >= 0 && t < this.pages.length) return this.pages[t];
            throw new Error("Invalid page number");
        }
        nextBy(t) {
            const e = this.pages.indexOf(t);
            return e < this.pages.length - 1 ? this.pages[e + 1] : null;
        }
        prevBy(t) {
            const e = this.pages.indexOf(t);
            return e > 0 ? this.pages[e - 1] : null;
        }
        getFlippingPage(t) {
            const e = this.currentSpreadIndex;
            if ("portrait" === this.render.getOrientation()) return 0 === t ? this.pages[e].newTemporaryCopy() : this.pages[e - 1];
            {
                const i = 0 === t ? this.getSpread()[e + 1] : this.getSpread()[e - 1];
                return 1 === i.length || 0 === t ? this.pages[i[0]] : this.pages[i[1]];
            }
        }
        getBottomPage(t) {
            const e = this.currentSpreadIndex;
            if ("portrait" === this.render.getOrientation()) return 0 === t ? this.pages[e + 1] : this.pages[e - 1];
            {
                const i = 0 === t ? this.getSpread()[e + 1] : this.getSpread()[e - 1];
                return 1 === i.length ? this.pages[i[0]] : 0 === t ? this.pages[i[1]] : this.pages[i[0]];
            }
        }
        showNext() {
            this.currentSpreadIndex < this.getSpread().length && (this.currentSpreadIndex++, this.showSpread());
        }
        showPrev() {
            this.currentSpreadIndex > 0 && (this.currentSpreadIndex--, this.showSpread());
        }
        getCurrentPageIndex() {
            return this.currentPageIndex;
        }
        show(t = null) {
            if ((null === t && (t = this.currentPageIndex), t < 0 || t >= this.pages.length)) return;
            const e = this.getSpreadIndexByPage(t);
            null !== e && ((this.currentSpreadIndex = e), this.showSpread());
        }
        getCurrentSpreadIndex() {
            return this.currentSpreadIndex;
        }
        setCurrentSpreadIndex(t) {
            if (!(t >= 0 && t < this.getSpread().length)) throw new Error("Invalid page");
            this.currentSpreadIndex = t;
        }
        showSpread() {
            const t = this.getSpread()[this.currentSpreadIndex];
            2 === t.length
                ? (this.render.setLeftPage(this.pages[t[0]]), this.render.setRightPage(this.pages[t[1]]))
                : "landscape" === this.render.getOrientation() && t[0] === this.pages.length - 1
                ? (this.render.setLeftPage(this.pages[t[0]]), this.render.setRightPage(null))
                : (this.render.setLeftPage(null), this.render.setRightPage(this.pages[t[0]])),
                (this.currentPageIndex = t[0]),
                this.app.updatePageIndex(this.currentPageIndex);
        }
    }
    class n extends s {
        constructor(t, e, i) {
            super(t, e), (this.imagesHref = i);
        }
        load() {
            for (const t of this.imagesHref) {
                const e = new i(this.render, t, "soft");
                e.load(), this.pages.push(e);
            }
            this.createSpread();
        }
    }
    class h {
        static GetDistanceBetweenTwoPoint(t, e) {
            return null === t || null === e ? 1 / 0 : Math.sqrt(Math.pow(e.x - t.x, 2) + Math.pow(e.y - t.y, 2));
        }
        static GetSegmentLength(t) {
            return h.GetDistanceBetweenTwoPoint(t[0], t[1]);
        }
        static GetAngleBetweenTwoLine(t, e) {
            const i = t[0].y - t[1].y,
                s = e[0].y - e[1].y,
                n = t[1].x - t[0].x,
                h = e[1].x - e[0].x;
            return Math.acos((i * s + n * h) / (Math.sqrt(i * i + n * n) * Math.sqrt(s * s + h * h)));
        }
        static PointInRect(t, e) {
            return null === e ? null : e.x >= t.left && e.x <= t.width + t.left && e.y >= t.top && e.y <= t.top + t.height ? e : null;
        }
        static GetRotatedPoint(t, e, i) {
            return { x: t.x * Math.cos(i) + t.y * Math.sin(i) + e.x, y: t.y * Math.cos(i) - t.x * Math.sin(i) + e.y };
        }
        static LimitPointToCircle(t, e, i) {
            if (h.GetDistanceBetweenTwoPoint(t, i) <= e) return i;
            const s = t.x,
                n = t.y,
                r = i.x,
                o = i.y;
            let a = Math.sqrt((Math.pow(e, 2) * Math.pow(s - r, 2)) / (Math.pow(s - r, 2) + Math.pow(n - o, 2))) + s;
            i.x < 0 && (a *= -1);
            let g = ((a - s) * (n - o)) / (s - r) + n;
            return s - r + n === 0 && (g = e), { x: a, y: g };
        }
        static GetIntersectBetweenTwoSegment(t, e, i) {
            return h.PointInRect(t, h.GetIntersectBeetwenTwoLine(e, i));
        }
        static GetIntersectBeetwenTwoLine(t, e) {
            const i = t[0].y - t[1].y,
                s = e[0].y - e[1].y,
                n = t[1].x - t[0].x,
                h = e[1].x - e[0].x,
                r = t[0].x * t[1].y - t[1].x * t[0].y,
                o = e[0].x * e[1].y - e[1].x * e[0].y,
                a = i * o - s * r,
                g = n * o - h * r,
                l = -(r * h - o * n) / (i * h - s * n),
                d = -(i * o - s * r) / (i * h - s * n);
            if (isFinite(l) && isFinite(d)) return { x: l, y: d };
            if (Math.abs(a - g) < 0.1) throw new Error("Segment included");
            return null;
        }
        static GetCordsFromTwoPoint(t, e) {
            const i = Math.abs(t.x - e.x),
                s = Math.abs(t.y - e.y),
                n = Math.max(i, s),
                h = [t];
            function r(t, e, i, s, n) {
                return e > t ? t + n * (i / s) : e < t ? t - n * (i / s) : t;
            }
            for (let o = 1; o <= n; o += 1) h.push({ x: r(t.x, e.x, i, n, o), y: r(t.y, e.y, s, n, o) });
            return h;
        }
    }
    class r extends e {
        constructor(t, e, i) {
            super(t, i), (this.copiedElement = null), (this.temporaryCopy = null), (this.isLoad = !1), (this.element = e), this.element.classList.add("stf__item"), this.element.classList.add("--" + i);
        }
        newTemporaryCopy() {
            return "hard" === this.nowDrawingDensity
                ? this
                : (null === this.temporaryCopy &&
                      ((this.copiedElement = this.element.cloneNode(!0)), this.element.parentElement.appendChild(this.copiedElement), (this.temporaryCopy = new r(this.render, this.copiedElement, this.nowDrawingDensity))),
                  this.getTemporaryCopy());
        }
        getTemporaryCopy() {
            return this.temporaryCopy;
        }
        hideTemporaryCopy() {
            null !== this.temporaryCopy && (this.copiedElement.remove(), (this.copiedElement = null), (this.temporaryCopy = null));
        }
        draw(t) {
            const e = t || this.nowDrawingDensity,
                i = this.render.convertToGlobal(this.state.position),
                s = this.render.getRect().pageWidth,
                n = this.render.getRect().height;
            this.element.classList.remove("--simple");
            const h = `\n            display: block;\n            z-index: ${this.element.style.zIndex};\n            left: 0;\n            top: 0;\n            width: ${s}px;\n            height: ${n}px;\n        `;
            "hard" === e ? this.drawHard(h) : this.drawSoft(i, h);
        }
        drawHard(t = "") {
            const e = this.render.getRect().left + this.render.getRect().width / 2,
                i = this.state.hardDrawingAngle,
                s =
                    t +
                    "\n                backface-visibility: hidden;\n                -webkit-backface-visibility: hidden;\n                clip-path: none;\n                -webkit-clip-path: none;\n            " +
                    (0 === this.orientation
                        ? `transform-origin: ${this.render.getRect().pageWidth}px 0; \n                   transform: translate3d(0, 0, 0) rotateY(${i}deg);`
                        : `transform-origin: 0 0; \n                   transform: translate3d(${e}px, 0, 0) rotateY(${i}deg);`);
            this.element.style.cssText = s;
        }
        drawSoft(t, e = "") {
            let i = "polygon( ";
            for (const t of this.state.area)
                if (null !== t) {
                    let e = 1 === this.render.getDirection() ? { x: -t.x + this.state.position.x, y: t.y - this.state.position.y } : { x: t.x - this.state.position.x, y: t.y - this.state.position.y };
                    (e = h.GetRotatedPoint(e, { x: 0, y: 0 }, this.state.angle)), (i += e.x + "px " + e.y + "px, ");
                }
            (i = i.slice(0, -2)), (i += ")");
            const s =
                e +
                `transform-origin: 0 0; clip-path: ${i}; -webkit-clip-path: ${i};` +
                (this.render.isSafari() && 0 === this.state.angle ? `transform: translate(${t.x}px, ${t.y}px);` : `transform: translate3d(${t.x}px, ${t.y}px, 0) rotate(${this.state.angle}rad);`);
            this.element.style.cssText = s;
        }
        simpleDraw(t) {
            const e = this.render.getRect(),
                i = e.pageWidth,
                s = e.height,
                n = 1 === t ? e.left + e.pageWidth : e.left,
                h = e.top;
            this.element.classList.add("--simple"),
                (this.element.style.cssText = `\n            position: absolute; \n            display: block; \n            height: ${s}px; \n            left: ${n}px; \n            top: ${h}px; \n            width: ${i}px; \n            z-index: ${
                    this.render.getSettings().startZIndex + 1
                };`);
        }
        getElement() {
            return this.element;
        }
        load() {
            this.isLoad = !0;
        }
        setOrientation(t) {
            super.setOrientation(t), this.element.classList.remove("--left", "--right"), this.element.classList.add(1 === t ? "--right" : "--left");
        }
        setDrawingDensity(t) {
            this.element.classList.remove("--soft", "--hard"), this.element.classList.add("--" + t), super.setDrawingDensity(t);
        }
    }
    class o extends s {
        constructor(t, e, i, s) {
            super(t, e), (this.element = i), (this.pagesElement = s);
        }
        load() {
            for (const t of this.pagesElement) {
                const e = new r(this.render, t, "hard" === t.dataset.density ? "hard" : "soft");
                e.load(), this.pages.push(e);
            }
            this.createSpread();
        }
    }
    class a {
        constructor(t, e, i, s) {
            (this.direction = t), (this.corner = e), (this.topIntersectPoint = null), (this.sideIntersectPoint = null), (this.bottomIntersectPoint = null), (this.pageWidth = parseInt(i, 10)), (this.pageHeight = parseInt(s, 10));
        }
        calc(t) {
            try {
                return (this.position = this.calcAngleAndPosition(t)), this.calculateIntersectPoint(this.position), !0;
            } catch (t) {
                return !1;
            }
        }
        getFlippingClipArea() {
            const t = [];
            let e = !1;
            return (
                t.push(this.rect.topLeft),
                t.push(this.topIntersectPoint),
                null === this.sideIntersectPoint ? (e = !0) : (t.push(this.sideIntersectPoint), null === this.bottomIntersectPoint && (e = !1)),
                t.push(this.bottomIntersectPoint),
                (e || "bottom" === this.corner) && t.push(this.rect.bottomLeft),
                t
            );
        }
        getBottomClipArea() {
            const t = [];
            return (
                t.push(this.topIntersectPoint),
                "top" === this.corner ? t.push({ x: this.pageWidth, y: 0 }) : (null !== this.topIntersectPoint && t.push({ x: this.pageWidth, y: 0 }), t.push({ x: this.pageWidth, y: this.pageHeight })),
                null !== this.sideIntersectPoint
                    ? h.GetDistanceBetweenTwoPoint(this.sideIntersectPoint, this.topIntersectPoint) >= 10 && t.push(this.sideIntersectPoint)
                    : "top" === this.corner && t.push({ x: this.pageWidth, y: this.pageHeight }),
                t.push(this.bottomIntersectPoint),
                t.push(this.topIntersectPoint),
                t
            );
        }
        getAngle() {
            return 0 === this.direction ? -this.angle : this.angle;
        }
        getRect() {
            return this.rect;
        }
        getPosition() {
            return this.position;
        }
        getActiveCorner() {
            return 0 === this.direction ? this.rect.topLeft : this.rect.topRight;
        }
        getDirection() {
            return this.direction;
        }
        getFlippingProgress() {
            return Math.abs(((this.position.x - this.pageWidth) / (2 * this.pageWidth)) * 100);
        }
        getCorner() {
            return this.corner;
        }
        getBottomPagePosition() {
            return 1 === this.direction ? { x: this.pageWidth, y: 0 } : { x: 0, y: 0 };
        }
        getShadowStartPoint() {
            return "top" === this.corner ? this.topIntersectPoint : null !== this.sideIntersectPoint ? this.sideIntersectPoint : this.topIntersectPoint;
        }
        getShadowAngle() {
            const t = h.GetAngleBetweenTwoLine(this.getSegmentToShadowLine(), [
                { x: 0, y: 0 },
                { x: this.pageWidth, y: 0 },
            ]);
            return 0 === this.direction ? t : Math.PI - t;
        }
        calcAngleAndPosition(t) {
            let e = t;
            if (
                (this.updateAngleAndGeometry(e),
                (e = "top" === this.corner ? this.checkPositionAtCenterLine(e, { x: 0, y: 0 }, { x: 0, y: this.pageHeight }) : this.checkPositionAtCenterLine(e, { x: 0, y: this.pageHeight }, { x: 0, y: 0 })),
                Math.abs(e.x - this.pageWidth) < 1 && Math.abs(e.y) < 1)
            )
                throw new Error("Point is too small");
            return e;
        }
        updateAngleAndGeometry(t) {
            (this.angle = this.calculateAngle(t)), (this.rect = this.getPageRect(t));
        }
        calculateAngle(t) {
            const e = this.pageWidth - t.x + 1,
                i = "bottom" === this.corner ? this.pageHeight - t.y : t.y;
            let s = 2 * Math.acos(e / Math.sqrt(i * i + e * e));
            i < 0 && (s = -s);
            const n = Math.PI - s;
            if (!isFinite(s) || (n >= 0 && n < 0.003)) throw new Error("The G point is too small");
            return "bottom" === this.corner && (s = -s), s;
        }
        getPageRect(t) {
            return "top" === this.corner
                ? this.getRectFromBasePoint(
                      [
                          { x: 0, y: 0 },
                          { x: this.pageWidth, y: 0 },
                          { x: 0, y: this.pageHeight },
                          { x: this.pageWidth, y: this.pageHeight },
                      ],
                      t
                  )
                : this.getRectFromBasePoint(
                      [
                          { x: 0, y: -this.pageHeight },
                          { x: this.pageWidth, y: -this.pageHeight },
                          { x: 0, y: 0 },
                          { x: this.pageWidth, y: 0 },
                      ],
                      t
                  );
        }
        getRectFromBasePoint(t, e) {
            return { topLeft: this.getRotatedPoint(t[0], e), topRight: this.getRotatedPoint(t[1], e), bottomLeft: this.getRotatedPoint(t[2], e), bottomRight: this.getRotatedPoint(t[3], e) };
        }
        getRotatedPoint(t, e) {
            return { x: t.x * Math.cos(this.angle) + t.y * Math.sin(this.angle) + e.x, y: t.y * Math.cos(this.angle) - t.x * Math.sin(this.angle) + e.y };
        }
        calculateIntersectPoint(t) {
            const e = { left: -1, top: -1, width: this.pageWidth + 2, height: this.pageHeight + 2 };
            "top" === this.corner
                ? ((this.topIntersectPoint = h.GetIntersectBetweenTwoSegment(
                      e,
                      [t, this.rect.topRight],
                      [
                          { x: 0, y: 0 },
                          { x: this.pageWidth, y: 0 },
                      ]
                  )),
                  (this.sideIntersectPoint = h.GetIntersectBetweenTwoSegment(
                      e,
                      [t, this.rect.bottomLeft],
                      [
                          { x: this.pageWidth, y: 0 },
                          { x: this.pageWidth, y: this.pageHeight },
                      ]
                  )),
                  (this.bottomIntersectPoint = h.GetIntersectBetweenTwoSegment(
                      e,
                      [this.rect.bottomLeft, this.rect.bottomRight],
                      [
                          { x: 0, y: this.pageHeight },
                          { x: this.pageWidth, y: this.pageHeight },
                      ]
                  )))
                : ((this.topIntersectPoint = h.GetIntersectBetweenTwoSegment(
                      e,
                      [this.rect.topLeft, this.rect.topRight],
                      [
                          { x: 0, y: 0 },
                          { x: this.pageWidth, y: 0 },
                      ]
                  )),
                  (this.sideIntersectPoint = h.GetIntersectBetweenTwoSegment(
                      e,
                      [t, this.rect.topLeft],
                      [
                          { x: this.pageWidth, y: 0 },
                          { x: this.pageWidth, y: this.pageHeight },
                      ]
                  )),
                  (this.bottomIntersectPoint = h.GetIntersectBetweenTwoSegment(
                      e,
                      [this.rect.bottomLeft, this.rect.bottomRight],
                      [
                          { x: 0, y: this.pageHeight },
                          { x: this.pageWidth, y: this.pageHeight },
                      ]
                  )));
        }
        checkPositionAtCenterLine(t, e, i) {
            let s = t;
            const n = h.LimitPointToCircle(e, this.pageWidth, s);
            s !== n && ((s = n), this.updateAngleAndGeometry(s));
            const r = Math.sqrt(Math.pow(this.pageWidth, 2) + Math.pow(this.pageHeight, 2));
            let o = this.rect.bottomRight,
                a = this.rect.topLeft;
            if (("bottom" === this.corner && ((o = this.rect.topRight), (a = this.rect.bottomLeft)), o.x <= 0)) {
                const t = h.LimitPointToCircle(i, r, a);
                t !== s && ((s = t), this.updateAngleAndGeometry(s));
            }
            return s;
        }
        getSegmentToShadowLine() {
            const t = this.getShadowStartPoint();
            return [t, t !== this.sideIntersectPoint && null !== this.sideIntersectPoint ? this.sideIntersectPoint : this.bottomIntersectPoint];
        }
    }
    class g {
        constructor(t, e) {
            (this.flippingPage = null), (this.bottomPage = null), (this.calc = null), (this.state = "read"), (this.render = t), (this.app = e);
        }
        fold(t) {
            this.setState("user_fold"), null === this.calc && this.start(t), this.do(this.render.convertToPage(t));
        }
        flip(t) {
            if (this.app.getSettings().disableFlipByClick && !this.isPointOnCorners(t)) return;
            if ((null !== this.calc && this.render.finishAnimation(), !this.start(t))) return;
            const e = this.getBoundsRect();
            this.setState("flipping");
            const i = e.height / 10,
                s = "bottom" === this.calc.getCorner() ? e.height - i : i,
                n = "bottom" === this.calc.getCorner() ? e.height : 0;
            this.calc.calc({ x: e.pageWidth - i, y: s }), this.animateFlippingTo({ x: e.pageWidth - i, y: s }, { x: -e.pageWidth, y: n }, !0);
        }
        start(t) {
            this.reset();
            const e = this.render.convertToBook(t),
                i = this.getBoundsRect(),
                s = this.getDirectionByPoint(e),
                n = e.y >= i.height / 2 ? "bottom" : "top";
            if (!this.checkDirection(s)) return !1;
            try {
                if (((this.flippingPage = this.app.getPageCollection().getFlippingPage(s)), (this.bottomPage = this.app.getPageCollection().getBottomPage(s)), "landscape" === this.render.getOrientation()))
                    if (1 === s) {
                        const t = this.app.getPageCollection().nextBy(this.flippingPage);
                        null !== t && this.flippingPage.getDensity() !== t.getDensity() && (this.flippingPage.setDrawingDensity("hard"), t.setDrawingDensity("hard"));
                    } else {
                        const t = this.app.getPageCollection().prevBy(this.flippingPage);
                        null !== t && this.flippingPage.getDensity() !== t.getDensity() && (this.flippingPage.setDrawingDensity("hard"), t.setDrawingDensity("hard"));
                    }
                return this.render.setDirection(s), (this.calc = new a(s, n, i.pageWidth.toString(10), i.height.toString(10))), !0;
            } catch (t) {
                return !1;
            }
        }
        do(t) {
            if (null !== this.calc && this.calc.calc(t)) {
                const t = this.calc.getFlippingProgress();
                this.bottomPage.setArea(this.calc.getBottomClipArea()),
                    this.bottomPage.setPosition(this.calc.getBottomPagePosition()),
                    this.bottomPage.setAngle(0),
                    this.bottomPage.setHardAngle(0),
                    this.flippingPage.setArea(this.calc.getFlippingClipArea()),
                    this.flippingPage.setPosition(this.calc.getActiveCorner()),
                    this.flippingPage.setAngle(this.calc.getAngle()),
                    0 === this.calc.getDirection() ? this.flippingPage.setHardAngle((90 * (200 - 2 * t)) / 100) : this.flippingPage.setHardAngle((-90 * (200 - 2 * t)) / 100),
                    this.render.setPageRect(this.calc.getRect()),
                    this.render.setBottomPage(this.bottomPage),
                    this.render.setFlippingPage(this.flippingPage),
                    this.render.setShadowData(this.calc.getShadowStartPoint(), this.calc.getShadowAngle(), t, this.calc.getDirection());
            }
        }
        flipToPage(t, e) {
            const i = this.app.getPageCollection().getCurrentSpreadIndex(),
                s = this.app.getPageCollection().getSpreadIndexByPage(t);
            try {
                s > i && (this.app.getPageCollection().setCurrentSpreadIndex(s - 1), this.flipNext(e)), s < i && (this.app.getPageCollection().setCurrentSpreadIndex(s + 1), this.flipPrev(e));
            } catch (t) {}
        }
        flipNext(t) {
            this.flip({ x: this.render.getRect().left + 2 * this.render.getRect().pageWidth - 10, y: "top" === t ? 1 : this.render.getRect().height - 2 });
        }
        flipPrev(t) {
            this.flip({ x: 10, y: "top" === t ? 1 : this.render.getRect().height - 2 });
        }
        stopMove() {
            if (null === this.calc) return;
            const t = this.calc.getPosition(),
                e = this.getBoundsRect(),
                i = "bottom" === this.calc.getCorner() ? e.height : 0;
            t.x <= 0 ? this.animateFlippingTo(t, { x: -e.pageWidth, y: i }, !0) : this.animateFlippingTo(t, { x: e.pageWidth, y: i }, !1);
        }
        showCorner(t) {
            if (!this.checkState("read", "fold_corner")) return;
            const e = this.getBoundsRect(),
                i = e.pageWidth;
            if (this.isPointOnCorners(t))
                if (null === this.calc) {
                    if (!this.start(t)) return;
                    this.setState("fold_corner"), this.calc.calc({ x: i - 1, y: 1 });
                    const s = 50,
                        n = "bottom" === this.calc.getCorner() ? e.height - 1 : 1,
                        h = "bottom" === this.calc.getCorner() ? e.height - s : s;
                    this.animateFlippingTo({ x: i - 1, y: n }, { x: i - s, y: h }, !1, !1);
                } else this.do(this.render.convertToPage(t));
            else this.setState("read"), this.render.finishAnimation(), this.stopMove();
        }
        animateFlippingTo(t, e, i, s = !0) {
            const n = h.GetCordsFromTwoPoint(t, e),
                r = [];
            for (const t of n) r.push(() => this.do(t));
            const o = this.getAnimationDuration(n.length);
            this.render.startAnimation(r, o, () => {
                this.calc &&
                    (i && (1 === this.calc.getDirection() ? this.app.turnToPrevPage() : this.app.turnToNextPage()),
                    s && (this.render.setBottomPage(null), this.render.setFlippingPage(null), this.render.clearShadow(), this.setState("read"), this.reset()));
            });
        }
        getCalculation() {
            return this.calc;
        }
        getState() {
            return this.state;
        }
        setState(t) {
            this.state !== t && (this.app.updateState(t), (this.state = t));
        }
        getDirectionByPoint(t) {
            const e = this.getBoundsRect();
            if ("portrait" === this.render.getOrientation()) {
                if (t.x - e.pageWidth <= e.width / 5) return 1;
            } else if (t.x < e.width / 2) return 1;
            return 0;
        }
        getAnimationDuration(t) {
            const e = this.app.getSettings().flippingTime;
            return t >= 1e3 ? e : (t / 1e3) * e;
        }
        checkDirection(t) {
            return 0 === t ? this.app.getCurrentPageIndex() < this.app.getPageCount() - 1 : this.app.getCurrentPageIndex() >= 1;
        }
        reset() {
            (this.calc = null), (this.flippingPage = null), (this.bottomPage = null);
        }
        getBoundsRect() {
            return this.render.getRect();
        }
        checkState(...t) {
            for (const e of t) if (this.state === e) return !0;
            return !1;
        }
        isPointOnCorners(t) {
            const e = this.getBoundsRect(),
                i = e.pageWidth,
                s = Math.sqrt(Math.pow(i, 2) + Math.pow(e.height, 2)) / 5,
                n = this.render.convertToBook(t);
            return n.x > 0 && n.y > 0 && n.x < e.width && n.y < e.height && (n.x < s || n.x > e.width - s) && (n.y < s || n.y > e.height - s);
        }
    }
    class l {
        constructor(t, e) {
            (this.leftPage = null),
                (this.rightPage = null),
                (this.flippingPage = null),
                (this.bottomPage = null),
                (this.direction = null),
                (this.orientation = null),
                (this.shadow = null),
                (this.animation = null),
                (this.pageRect = null),
                (this.boundsRect = null),
                (this.timer = 0),
                (this.safari = !1),
                (this.setting = e),
                (this.app = t);
            const i = new RegExp("Version\\/[\\d\\.]+.*Safari/");
            this.safari = null !== i.exec(window.navigator.userAgent);
        }
        render(t) {
            if (null !== this.animation) {
                const e = Math.round((t - this.animation.startedAt) / this.animation.durationFrame);
                e < this.animation.frames.length ? this.animation.frames[e]() : (this.animation.onAnimateEnd(), (this.animation = null));
            }
            (this.timer = t), this.drawFrame();
        }
        start() {
            this.update();
            const t = (e) => {
                this.render(e), requestAnimationFrame(t);
            };
            requestAnimationFrame(t);
        }
        startAnimation(t, e, i) {
            this.finishAnimation(), (this.animation = { frames: t, duration: e, durationFrame: e / t.length, onAnimateEnd: i, startedAt: this.timer });
        }
        finishAnimation() {
            null !== this.animation && (this.animation.frames[this.animation.frames.length - 1](), null !== this.animation.onAnimateEnd && this.animation.onAnimateEnd()), (this.animation = null);
        }
        update() {
            this.boundsRect = null;
            const t = this.calculateBoundsRect();
            this.orientation !== t && ((this.orientation = t), this.app.updateOrientation(t));
        }
        calculateBoundsRect() {
            let t = "landscape";
            const e = this.getBlockWidth(),
                i = e / 2,
                s = this.getBlockHeight() / 2,
                n = this.setting.width / this.setting.height;
            let h = this.setting.width,
                r = this.setting.height,
                o = i - h;
            return (
                "stretch" === this.setting.size
                    ? (e < 2 * this.setting.minWidth && this.app.getSettings().usePortrait && (t = "portrait"),
                      (h = "portrait" === t ? this.getBlockWidth() : this.getBlockWidth() / 2),
                      h > this.setting.maxWidth && (h = this.setting.maxWidth),
                      (r = h / n),
                      r > this.getBlockHeight() && ((r = this.getBlockHeight()), (h = r * n)),
                      (o = "portrait" === t ? i - h / 2 - h : i - h))
                    : e < 2 * h && this.app.getSettings().usePortrait && ((t = "portrait"), (o = i - h / 2 - h)),
                (this.boundsRect = { left: o, top: s - r / 2, width: 2 * h, height: r, pageWidth: h }),
                t
            );
        }
        setShadowData(t, e, i, s) {
            if (!this.app.getSettings().drawShadow) return;
            const n = 100 * this.getSettings().maxShadowOpacity;
            this.shadow = { pos: t, angle: e, width: (((3 * this.getRect().pageWidth) / 4) * i) / 100, opacity: ((100 - i) * n) / 100 / 100, direction: s, progress: 2 * i };
        }
        clearShadow() {
            this.shadow = null;
        }
        getBlockWidth() {
            return this.app.getUI().getDistElement().offsetWidth;
        }
        getBlockHeight() {
            return this.app.getUI().getDistElement().offsetHeight;
        }
        getDirection() {
            return this.direction;
        }
        getRect() {
            return null === this.boundsRect && this.calculateBoundsRect(), this.boundsRect;
        }
        getSettings() {
            return this.app.getSettings();
        }
        getOrientation() {
            return this.orientation;
        }
        setPageRect(t) {
            this.pageRect = t;
        }
        setDirection(t) {
            this.direction = t;
        }
        setRightPage(t) {
            null !== t && t.setOrientation(1), (this.rightPage = t);
        }
        setLeftPage(t) {
            null !== t && t.setOrientation(0), (this.leftPage = t);
        }
        setBottomPage(t) {
            null !== t && t.setOrientation(1 === this.direction ? 0 : 1), (this.bottomPage = t);
        }
        setFlippingPage(t) {
            null !== t && t.setOrientation(0 === this.direction && "portrait" !== this.orientation ? 0 : 1), (this.flippingPage = t);
        }
        convertToBook(t) {
            const e = this.getRect();
            return { x: t.x - e.left, y: t.y - e.top };
        }
        isSafari() {
            return this.safari;
        }
        convertToPage(t, e) {
            e || (e = this.direction);
            const i = this.getRect();
            return { x: 0 === e ? t.x - i.left - i.width / 2 : i.width / 2 - t.x + i.left, y: t.y - i.top };
        }
        convertToGlobal(t, e) {
            if ((e || (e = this.direction), null == t)) return null;
            const i = this.getRect();
            return { x: 0 === e ? t.x + i.left + i.width / 2 : i.width / 2 - t.x + i.left, y: t.y + i.top };
        }
        convertRectToGlobal(t, e) {
            return (
                e || (e = this.direction),
                { topLeft: this.convertToGlobal(t.topLeft, e), topRight: this.convertToGlobal(t.topRight, e), bottomLeft: this.convertToGlobal(t.bottomLeft, e), bottomRight: this.convertToGlobal(t.bottomRight, e) }
            );
        }
    }
    class d extends l {
        constructor(t, e, i) {
            super(t, e), (this.canvas = i), (this.ctx = i.getContext("2d"));
        }
        getContext() {
            return this.ctx;
        }
        reload() {}
        drawFrame() {
            this.clear(),
                "portrait" !== this.orientation && null != this.leftPage && this.leftPage.simpleDraw(0),
                null != this.rightPage && this.rightPage.simpleDraw(1),
                null != this.bottomPage && this.bottomPage.draw(),
                this.drawBookShadow(),
                null != this.flippingPage && this.flippingPage.draw(),
                null != this.shadow && (this.drawOuterShadow(), this.drawInnerShadow());
            const t = this.getRect();
            "portrait" === this.orientation && (this.ctx.beginPath(), this.ctx.rect(t.left + t.pageWidth, t.top, t.width, t.height), this.ctx.clip());
        }
        drawBookShadow() {
            const t = this.getRect();
            this.ctx.save(), this.ctx.beginPath();
            const e = t.width / 20;
            this.ctx.rect(t.left, t.top, t.width, t.height);
            const i = { x: t.left + t.width / 2 - e / 2, y: 0 };
            this.ctx.translate(i.x, i.y);
            const s = this.ctx.createLinearGradient(0, 0, e, 0);
            s.addColorStop(0, "rgba(0, 0, 0, 0)"),
                s.addColorStop(0.4, "rgba(0, 0, 0, 0.2)"),
                s.addColorStop(0.49, "rgba(0, 0, 0, 0.1)"),
                s.addColorStop(0.5, "rgba(0, 0, 0, 0.5)"),
                s.addColorStop(0.51, "rgba(0, 0, 0, 0.4)"),
                s.addColorStop(1, "rgba(0, 0, 0, 0)"),
                this.ctx.clip(),
                (this.ctx.fillStyle = s),
                this.ctx.fillRect(0, 0, e, 2 * t.height),
                this.ctx.restore();
        }
        drawOuterShadow() {
            const t = this.getRect();
            this.ctx.save(), this.ctx.beginPath(), this.ctx.rect(t.left, t.top, t.width, t.height);
            const e = this.convertToGlobal({ x: this.shadow.pos.x, y: this.shadow.pos.y });
            this.ctx.translate(e.x, e.y), this.ctx.rotate(Math.PI + this.shadow.angle + Math.PI / 2);
            const i = this.ctx.createLinearGradient(0, 0, this.shadow.width, 0);
            0 === this.shadow.direction
                ? (this.ctx.translate(0, -100), i.addColorStop(0, "rgba(0, 0, 0, " + this.shadow.opacity + ")"), i.addColorStop(1, "rgba(0, 0, 0, 0)"))
                : (this.ctx.translate(-this.shadow.width, -100), i.addColorStop(0, "rgba(0, 0, 0, 0)"), i.addColorStop(1, "rgba(0, 0, 0, " + this.shadow.opacity + ")")),
                this.ctx.clip(),
                (this.ctx.fillStyle = i),
                this.ctx.fillRect(0, 0, this.shadow.width, 2 * t.height),
                this.ctx.restore();
        }
        drawInnerShadow() {
            const t = this.getRect();
            this.ctx.save(), this.ctx.beginPath();
            const e = this.convertToGlobal({ x: this.shadow.pos.x, y: this.shadow.pos.y }),
                i = this.convertRectToGlobal(this.pageRect);
            this.ctx.moveTo(i.topLeft.x, i.topLeft.y),
                this.ctx.lineTo(i.topRight.x, i.topRight.y),
                this.ctx.lineTo(i.bottomRight.x, i.bottomRight.y),
                this.ctx.lineTo(i.bottomLeft.x, i.bottomLeft.y),
                this.ctx.translate(e.x, e.y),
                this.ctx.rotate(Math.PI + this.shadow.angle + Math.PI / 2);
            const s = (3 * this.shadow.width) / 4,
                n = this.ctx.createLinearGradient(0, 0, s, 0);
            0 === this.shadow.direction
                ? (this.ctx.translate(-s, -100),
                  n.addColorStop(1, "rgba(0, 0, 0, " + this.shadow.opacity + ")"),
                  n.addColorStop(0.9, "rgba(0, 0, 0, 0.05)"),
                  n.addColorStop(0.7, "rgba(0, 0, 0, " + this.shadow.opacity + ")"),
                  n.addColorStop(0, "rgba(0, 0, 0, 0)"))
                : (this.ctx.translate(0, -100),
                  n.addColorStop(0, "rgba(0, 0, 0, " + this.shadow.opacity + ")"),
                  n.addColorStop(0.1, "rgba(0, 0, 0, 0.05)"),
                  n.addColorStop(0.3, "rgba(0, 0, 0, " + this.shadow.opacity + ")"),
                  n.addColorStop(1, "rgba(0, 0, 0, 0)")),
                this.ctx.clip(),
                (this.ctx.fillStyle = n),
                this.ctx.fillRect(0, 0, s, 2 * t.height),
                this.ctx.restore();
        }
        clear() {
            (this.ctx.fillStyle = "white"), this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        }
    }
    class p {
        constructor(t, e, i) {
            (this.touchPoint = null),
                (this.swipeTimeout = 250),
                (this.onResize = () => {
                    this.update();
                }),
                (this.onMouseDown = (t) => {
                    if (this.checkTarget(t.target)) {
                        const e = this.getMousePos(t.clientX, t.clientY);
                        this.app.startUserTouch(e), t.preventDefault();
                    }
                }),
                (this.onTouchStart = (t) => {
                    if (this.checkTarget(t.target) && t.changedTouches.length > 0) {
                        const e = t.changedTouches[0],
                            i = this.getMousePos(e.clientX, e.clientY);
                        (this.touchPoint = { point: i, time: Date.now() }),
                            setTimeout(() => {
                                null !== this.touchPoint && this.app.startUserTouch(i);
                            }, this.swipeTimeout),
                            this.app.getSettings().mobileScrollSupport || t.preventDefault();
                    }
                }),
                (this.onMouseUp = (t) => {
                    const e = this.getMousePos(t.clientX, t.clientY);
                    this.app.userStop(e);
                }),
                (this.onMouseMove = (t) => {
                    const e = this.getMousePos(t.clientX, t.clientY);
                    this.app.userMove(e, !1);
                }),
                (this.onTouchMove = (t) => {
                    if (t.changedTouches.length > 0) {
                        const e = t.changedTouches[0],
                            i = this.getMousePos(e.clientX, e.clientY);
                        this.app.getSettings().mobileScrollSupport
                            ? (null !== this.touchPoint && (Math.abs(this.touchPoint.point.x - i.x) > 10 || "read" !== this.app.getState()) && t.cancelable && this.app.userMove(i, !0), "read" !== this.app.getState() && t.preventDefault())
                            : this.app.userMove(i, !0);
                    }
                }),
                (this.onTouchEnd = (t) => {
                    if (t.changedTouches.length > 0) {
                        const e = t.changedTouches[0],
                            i = this.getMousePos(e.clientX, e.clientY);
                        let s = !1;
                        if (null !== this.touchPoint) {
                            const t = i.x - this.touchPoint.point.x,
                                e = Math.abs(i.y - this.touchPoint.point.y);
                            Math.abs(t) > this.swipeDistance &&
                                e < 2 * this.swipeDistance &&
                                Date.now() - this.touchPoint.time < this.swipeTimeout &&
                                (t > 0
                                    ? this.app.flipPrev(this.touchPoint.point.y < this.app.getRender().getRect().height / 2 ? "top" : "bottom")
                                    : this.app.flipNext(this.touchPoint.point.y < this.app.getRender().getRect().height / 2 ? "top" : "bottom"),
                                (s = !0)),
                                (this.touchPoint = null);
                        }
                        this.app.userStop(i, s);
                    }
                }),
                (this.parentElement = t),
                t.classList.add("stf__parent"),
                t.insertAdjacentHTML("afterbegin", '<div class="stf__wrapper"></div>'),
                (this.wrapper = t.querySelector(".stf__wrapper")),
                (this.app = e);
            const s = this.app.getSettings().usePortrait ? 1 : 2;
            (t.style.minWidth = i.minWidth * s + "px"),
                (t.style.minHeight = i.minHeight + "px"),
                "fixed" === i.size && ((t.style.minWidth = i.width * s + "px"), (t.style.minHeight = i.height + "px")),
                i.autoSize && ((t.style.width = "100%"), (t.style.maxWidth = 2 * i.maxWidth + "px")),
                (t.style.display = "block"),
                window.addEventListener("resize", this.onResize, !1),
                (this.swipeDistance = i.swipeDistance);
        }
        destroy() {
            this.app.getSettings().useMouseEvents && this.removeHandlers(), this.distElement.remove(), this.wrapper.remove();
        }
        getDistElement() {
            return this.distElement;
        }
        getWrapper() {
            return this.wrapper;
        }
        setOrientationStyle(t) {
            this.wrapper.classList.remove("--portrait", "--landscape"),
                "portrait" === t
                    ? (this.app.getSettings().autoSize && (this.wrapper.style.paddingBottom = (this.app.getSettings().height / this.app.getSettings().width) * 100 + "%"), this.wrapper.classList.add("--portrait"))
                    : (this.app.getSettings().autoSize && (this.wrapper.style.paddingBottom = (this.app.getSettings().height / (2 * this.app.getSettings().width)) * 100 + "%"), this.wrapper.classList.add("--landscape")),
                this.update();
        }
        removeHandlers() {
            window.removeEventListener("resize", this.onResize),
                this.distElement.removeEventListener("mousedown", this.onMouseDown),
                this.distElement.removeEventListener("touchstart", this.onTouchStart),
                window.removeEventListener("mousemove", this.onMouseMove),
                window.removeEventListener("touchmove", this.onTouchMove),
                window.removeEventListener("mouseup", this.onMouseUp),
                window.removeEventListener("touchend", this.onTouchEnd);
        }
        setHandlers() {
            window.addEventListener("resize", this.onResize, !1),
                this.app.getSettings().useMouseEvents &&
                    (this.distElement.addEventListener("mousedown", this.onMouseDown),
                    this.distElement.addEventListener("touchstart", this.onTouchStart),
                    window.addEventListener("mousemove", this.onMouseMove),
                    window.addEventListener("touchmove", this.onTouchMove, { passive: !this.app.getSettings().mobileScrollSupport }),
                    window.addEventListener("mouseup", this.onMouseUp),
                    window.addEventListener("touchend", this.onTouchEnd));
        }
        getMousePos(t, e) {
            const i = this.distElement.getBoundingClientRect();
            return { x: t - i.left, y: e - i.top };
        }
        checkTarget(t) {
            return !this.app.getSettings().clickEventForward || !["a", "button"].includes(t.tagName.toLowerCase());
        }
    }
    class c extends p {
        constructor(t, e, i, s) {
            super(t, e, i), this.wrapper.insertAdjacentHTML("afterbegin", '<div class="stf__block"></div>'), (this.distElement = t.querySelector(".stf__block")), (this.items = s);
            for (const t of s) this.distElement.appendChild(t);
            this.setHandlers();
        }
        clear() {
            for (const t of this.items) this.parentElement.appendChild(t);
        }
        updateItems(t) {
            this.removeHandlers(), (this.distElement.innerHTML = "");
            for (const e of t) this.distElement.appendChild(e);
            (this.items = t), this.setHandlers();
        }
        update() {
            this.app.getRender().update();
        }
    }
    class u extends p {
        constructor(t, e, i) {
            super(t, e, i), (this.wrapper.innerHTML = '<canvas class="stf__canvas"></canvas>'), (this.canvas = t.querySelectorAll("canvas")[0]), (this.distElement = this.canvas), this.resizeCanvas(), this.setHandlers();
        }
        resizeCanvas() {
            const t = getComputedStyle(this.canvas),
                e = parseInt(t.getPropertyValue("width"), 10),
                i = parseInt(t.getPropertyValue("height"), 10);
            (this.canvas.width = e), (this.canvas.height = i);
        }
        getCanvas() {
            return this.canvas;
        }
        update() {
            this.resizeCanvas(), this.app.getRender().update();
        }
    }
    class w extends l {
        constructor(t, e, i) {
            super(t, e), (this.outerShadow = null), (this.innerShadow = null), (this.hardShadow = null), (this.hardInnerShadow = null), (this.element = i), this.createShadows();
        }
        createShadows() {
            this.element.insertAdjacentHTML(
                "beforeend",
                '<div class="stf__outerShadow"></div>\n             <div class="stf__innerShadow"></div>\n             <div class="stf__hardShadow"></div>\n             <div class="stf__hardInnerShadow"></div>'
            ),
                (this.outerShadow = this.element.querySelector(".stf__outerShadow")),
                (this.innerShadow = this.element.querySelector(".stf__innerShadow")),
                (this.hardShadow = this.element.querySelector(".stf__hardShadow")),
                (this.hardInnerShadow = this.element.querySelector(".stf__hardInnerShadow"));
        }
        clearShadow() {
            super.clearShadow(),
                (this.outerShadow.style.cssText = "display: none"),
                (this.innerShadow.style.cssText = "display: none"),
                (this.hardShadow.style.cssText = "display: none"),
                (this.hardInnerShadow.style.cssText = "display: none");
        }
        reload() {
            this.element.querySelector(".stf__outerShadow") || this.createShadows();
        }
        drawHardInnerShadow() {
            const t = this.getRect(),
                e = this.shadow.progress > 100 ? 200 - this.shadow.progress : this.shadow.progress;
            let i = ((100 - e) * (2.5 * t.pageWidth)) / 100 + 20;
            i > t.pageWidth && (i = t.pageWidth);
            let s = `\n            display: block;\n            z-index: ${(this.getSettings().startZIndex + 5).toString(10)};\n            width: ${i}px;\n            height: ${
                t.height
            }px;\n            background: linear-gradient(to right,\n                rgba(0, 0, 0, ${(this.shadow.opacity * e) / 100}) 5%,\n                rgba(0, 0, 0, 0) 100%);\n            left: ${
                t.left + t.width / 2
            }px;\n            transform-origin: 0 0;\n        `;
            (s += (0 === this.getDirection() && this.shadow.progress > 100) || (1 === this.getDirection() && this.shadow.progress <= 100) ? "transform: translate3d(0, 0, 0);" : "transform: translate3d(0, 0, 0) rotateY(180deg);"),
                (this.hardInnerShadow.style.cssText = s);
        }
        drawHardOuterShadow() {
            const t = this.getRect();
            let e = ((100 - (this.shadow.progress > 100 ? 200 - this.shadow.progress : this.shadow.progress)) * (2.5 * t.pageWidth)) / 100 + 20;
            e > t.pageWidth && (e = t.pageWidth);
            let i = `\n            display: block;\n            z-index: ${(this.getSettings().startZIndex + 4).toString(10)};\n            width: ${e}px;\n            height: ${
                t.height
            }px;\n            background: linear-gradient(to left, rgba(0, 0, 0, ${this.shadow.opacity}) 5%, rgba(0, 0, 0, 0) 100%);\n            left: ${t.left + t.width / 2}px;\n            transform-origin: 0 0;\n        `;
            (i += (0 === this.getDirection() && this.shadow.progress > 100) || (1 === this.getDirection() && this.shadow.progress <= 100) ? "transform: translate3d(0, 0, 0) rotateY(180deg);" : "transform: translate3d(0, 0, 0);"),
                (this.hardShadow.style.cssText = i);
        }
        drawInnerShadow() {
            const t = this.getRect(),
                e = (3 * this.shadow.width) / 4,
                i = 0 === this.getDirection() ? e : 0,
                s = 0 === this.getDirection() ? "to left" : "to right",
                n = this.convertToGlobal(this.shadow.pos),
                r = this.shadow.angle + (3 * Math.PI) / 2,
                o = [this.pageRect.topLeft, this.pageRect.topRight, this.pageRect.bottomRight, this.pageRect.bottomLeft];
            let a = "polygon( ";
            for (const t of o) {
                let e = 1 === this.getDirection() ? { x: -t.x + this.shadow.pos.x, y: t.y - this.shadow.pos.y } : { x: t.x - this.shadow.pos.x, y: t.y - this.shadow.pos.y };
                (e = h.GetRotatedPoint(e, { x: i, y: 100 }, r)), (a += e.x + "px " + e.y + "px, ");
            }
            (a = a.slice(0, -2)), (a += ")");
            const g = `\n            display: block;\n            z-index: ${(this.getSettings().startZIndex + 10).toString(10)};\n            width: ${e}px;\n            height: ${
                2 * t.height
            }px;\n            background: linear-gradient(${s},\n                rgba(0, 0, 0, ${this.shadow.opacity}) 5%,\n                rgba(0, 0, 0, 0.05) 15%,\n                rgba(0, 0, 0, ${
                this.shadow.opacity
            }) 35%,\n                rgba(0, 0, 0, 0) 100%);\n            transform-origin: ${i}px 100px;\n            transform: translate3d(${n.x - i}px, ${
                n.y - 100
            }px, 0) rotate(${r}rad);\n            clip-path: ${a};\n            -webkit-clip-path: ${a};\n        `;
            this.innerShadow.style.cssText = g;
        }
        drawOuterShadow() {
            const t = this.getRect(),
                e = this.convertToGlobal({ x: this.shadow.pos.x, y: this.shadow.pos.y }),
                i = this.shadow.angle + (3 * Math.PI) / 2,
                s = 1 === this.getDirection() ? this.shadow.width : 0,
                n = 0 === this.getDirection() ? "to right" : "to left",
                r = [
                    { x: 0, y: 0 },
                    { x: t.pageWidth, y: 0 },
                    { x: t.pageWidth, y: t.height },
                    { x: 0, y: t.height },
                ];
            let o = "polygon( ";
            for (const t of r)
                if (null !== t) {
                    let e = 1 === this.getDirection() ? { x: -t.x + this.shadow.pos.x, y: t.y - this.shadow.pos.y } : { x: t.x - this.shadow.pos.x, y: t.y - this.shadow.pos.y };
                    (e = h.GetRotatedPoint(e, { x: s, y: 100 }, i)), (o += e.x + "px " + e.y + "px, ");
                }
            (o = o.slice(0, -2)), (o += ")");
            const a = `\n            display: block;\n            z-index: ${(this.getSettings().startZIndex + 10).toString(10)};\n            width: ${this.shadow.width}px;\n            height: ${
                2 * t.height
            }px;\n            background: linear-gradient(${n}, rgba(0, 0, 0, ${this.shadow.opacity}), rgba(0, 0, 0, 0));\n            transform-origin: ${s}px 100px;\n            transform: translate3d(${e.x - s}px, ${
                e.y - 100
            }px, 0) rotate(${i}rad);\n            clip-path: ${o};\n            -webkit-clip-path: ${o};\n        `;
            this.outerShadow.style.cssText = a;
        }
        drawLeftPage() {
            "portrait" !== this.orientation &&
                null !== this.leftPage &&
                (1 === this.direction && null !== this.flippingPage && "hard" === this.flippingPage.getDrawingDensity()
                    ? ((this.leftPage.getElement().style.zIndex = (this.getSettings().startZIndex + 5).toString(10)),
                      this.leftPage.setHardDrawingAngle(180 + this.flippingPage.getHardAngle()),
                      this.leftPage.draw(this.flippingPage.getDrawingDensity()))
                    : this.leftPage.simpleDraw(0));
        }
        drawRightPage() {
            null !== this.rightPage &&
                (0 === this.direction && null !== this.flippingPage && "hard" === this.flippingPage.getDrawingDensity()
                    ? ((this.rightPage.getElement().style.zIndex = (this.getSettings().startZIndex + 5).toString(10)),
                      this.rightPage.setHardDrawingAngle(180 + this.flippingPage.getHardAngle()),
                      this.rightPage.draw(this.flippingPage.getDrawingDensity()))
                    : this.rightPage.simpleDraw(1));
        }
        drawBottomPage() {
            if (null === this.bottomPage) return;
            const t = null != this.flippingPage ? this.flippingPage.getDrawingDensity() : null;
            ("portrait" === this.orientation && 1 === this.direction) || ((this.bottomPage.getElement().style.zIndex = (this.getSettings().startZIndex + 3).toString(10)), this.bottomPage.draw(t));
        }
        drawFrame() {
            this.clear(),
                this.drawLeftPage(),
                this.drawRightPage(),
                this.drawBottomPage(),
                null != this.flippingPage && ((this.flippingPage.getElement().style.zIndex = (this.getSettings().startZIndex + 5).toString(10)), this.flippingPage.draw()),
                null != this.shadow && null !== this.flippingPage && ("soft" === this.flippingPage.getDrawingDensity() ? (this.drawOuterShadow(), this.drawInnerShadow()) : (this.drawHardOuterShadow(), this.drawHardInnerShadow()));
        }
        clear() {
            for (const t of this.app.getPageCollection().getPages())
                t !== this.leftPage && t !== this.rightPage && t !== this.flippingPage && t !== this.bottomPage && (t.getElement().style.cssText = "display: none"), t.getTemporaryCopy() !== this.flippingPage && t.hideTemporaryCopy();
        }
        update() {
            super.update(), null !== this.rightPage && this.rightPage.setOrientation(1), null !== this.leftPage && this.leftPage.setOrientation(0);
        }
    }
    class x {
        constructor() {
            this._default = {
                startPage: 0,
                size: "fixed",
                width: 0,
                height: 0,
                minWidth: 0,
                maxWidth: 0,
                minHeight: 0,
                maxHeight: 0,
                drawShadow: !0,
                flippingTime: 1e3,
                usePortrait: !0,
                startZIndex: 0,
                autoSize: !0,
                maxShadowOpacity: 1,
                showCover: !1,
                mobileScrollSupport: !0,
                swipeDistance: 30,
                clickEventForward: !0,
                useMouseEvents: !0,
                showPageCorners: !0,
                disableFlipByClick: !1,
            };
        }
        getSettings(t) {
            const e = this._default;
            if ((Object.assign(e, t), "stretch" !== e.size && "fixed" !== e.size)) throw new Error('Invalid size type. Available only "fixed" and "stretch" value');
            if (e.width <= 0 || e.height <= 0) throw new Error("Invalid width or height");
            if (e.flippingTime <= 0) throw new Error("Invalid flipping time");
            return (
                "stretch" === e.size
                    ? (e.minWidth <= 0 && (e.minWidth = 100), e.maxWidth < e.minWidth && (e.maxWidth = 2e3), e.minHeight <= 0 && (e.minHeight = 100), e.maxHeight < e.minHeight && (e.maxHeight = 2e3))
                    : ((e.minWidth = e.width), (e.maxWidth = e.width), (e.minHeight = e.height), (e.maxHeight = e.height)),
                e
            );
        }
    }
    !(function (t, e) {
        void 0 === e && (e = {});
        var i = e.insertAt;
        if (t && "undefined" != typeof document) {
            var s = document.head || document.getElementsByTagName("head")[0],
                n = document.createElement("style");
            (n.type = "text/css"), "top" === i && s.firstChild ? s.insertBefore(n, s.firstChild) : s.appendChild(n), n.styleSheet ? (n.styleSheet.cssText = t) : n.appendChild(document.createTextNode(t));
        }
    })(
        ".stf__parent {\n  position: relative;\n  display: block;\n  box-sizing: border-box;\n  transform: translateZ(0);\n\n  -ms-touch-action: pan-y;\n  touch-action: pan-y;\n}\n\n.sft__wrapper {\n  position: relative;\n  width: 100%;\n  box-sizing: border-box;\n}\n\n.stf__parent canvas {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  left: 0;\n  top: 0;\n}\n\n.stf__block {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  box-sizing: border-box;\n  perspective: 2000px;\n}\n\n.stf__item {\n  display: none;\n  position: absolute;\n  transform-style: preserve-3d;\n}\n\n.stf__outerShadow {\n  position: absolute;\n  left: 0;\n  top: 0;\n}\n\n.stf__innerShadow {\n  position: absolute;\n  left: 0;\n  top: 0;\n}\n\n.stf__hardShadow {\n  position: absolute;\n  left: 0;\n  top: 0;\n}\n\n.stf__hardInnerShadow {\n  position: absolute;\n  left: 0;\n  top: 0;\n}"
    );
    (t.PageFlip = class extends class {
        constructor() {
            this.events = new Map();
        }
        on(t, e) {
            return this.events.has(t) ? this.events.get(t).push(e) : this.events.set(t, [e]), this;
        }
        off(t) {
            this.events.delete(t);
        }
        trigger(t, e, i = null) {
            if (this.events.has(t)) for (const s of this.events.get(t)) s({ data: i, object: e });
        }
    } {
        constructor(t, e) {
            super(), (this.isUserTouch = !1), (this.isUserMove = !1), (this.setting = null), (this.pages = null), (this.setting = new x().getSettings(e)), (this.block = t);
        }
        destroy() {
            this.ui.destroy(), this.block.remove();
        }
        update() {
            this.render.update(), this.pages.show();
        }
        loadFromImages(t) {
            this.ui = new u(this.block, this, this.setting);
            const e = this.ui.getCanvas();
            (this.render = new d(this, this.setting, e)),
                (this.flipController = new g(this.render, this)),
                (this.pages = new n(this, this.render, t)),
                this.pages.load(),
                this.render.start(),
                this.pages.show(this.setting.startPage),
                setTimeout(() => {
                    this.ui.update(), this.trigger("init", this, { page: this.setting.startPage, mode: this.render.getOrientation() });
                }, 1);
        }
        loadFromHTML(t) {
            (this.ui = new c(this.block, this, this.setting, t)),
                (this.render = new w(this, this.setting, this.ui.getDistElement())),
                (this.flipController = new g(this.render, this)),
                (this.pages = new o(this, this.render, this.ui.getDistElement(), t)),
                this.pages.load(),
                this.render.start(),
                this.pages.show(this.setting.startPage),
                setTimeout(() => {
                    this.ui.update(), this.trigger("init", this, { page: this.setting.startPage, mode: this.render.getOrientation() });
                }, 1);
        }
        updateFromImages(t) {
            const e = this.pages.getCurrentPageIndex();
            this.pages.destroy(), (this.pages = new n(this, this.render, t)), this.pages.load(), this.pages.show(e), this.trigger("update", this, { page: e, mode: this.render.getOrientation() });
        }
        updateFromHtml(t) {
            const e = this.pages.getCurrentPageIndex();
            this.pages.destroy(),
                (this.pages = new o(this, this.render, this.ui.getDistElement(), t)),
                this.pages.load(),
                this.ui.updateItems(t),
                this.render.reload(),
                this.pages.show(e),
                this.trigger("update", this, { page: e, mode: this.render.getOrientation() });
        }
        clear() {
            this.pages.destroy(), this.ui.clear();
        }
        turnToPrevPage() {
            this.pages.showPrev();
        }
        turnToNextPage() {
            this.pages.showNext();
        }
        turnToPage(t) {
            this.pages.show(t);
        }
        flipNext(t = "top") {
            this.flipController.flipNext(t);
        }
        flipPrev(t = "top") {
            this.flipController.flipPrev(t);
        }
        flip(t, e = "top") {
            this.flipController.flipToPage(t, e);
        }
        updateState(t) {
            this.trigger("changeState", this, t);
        }
        updatePageIndex(t) {
            this.trigger("flip", this, t);
        }
        updateOrientation(t) {
            this.ui.setOrientationStyle(t), this.update(), this.trigger("changeOrientation", this, t);
        }
        getPageCount() {
            return this.pages.getPageCount();
        }
        getCurrentPageIndex() {
            return this.pages.getCurrentPageIndex();
        }
        getPage(t) {
            return this.pages.getPage(t);
        }
        getRender() {
            return this.render;
        }
        getFlipController() {
            return this.flipController;
        }
        getOrientation() {
            return this.render.getOrientation();
        }
        getBoundsRect() {
            return this.render.getRect();
        }
        getSettings() {
            return this.setting;
        }
        getUI() {
            return this.ui;
        }
        getState() {
            return this.flipController.getState();
        }
        getPageCollection() {
            return this.pages;
        }
        startUserTouch(t) {
            (this.mousePosition = t), (this.isUserTouch = !0), (this.isUserMove = !1);
        }
        userMove(t, e) {
            this.isUserTouch || e || !this.setting.showPageCorners ? this.isUserTouch && h.GetDistanceBetweenTwoPoint(this.mousePosition, t) > 5 && ((this.isUserMove = !0), this.flipController.fold(t)) : this.flipController.showCorner(t);
        }
        userStop(t, e = !1) {
            this.isUserTouch && ((this.isUserTouch = !1), e || (this.isUserMove ? this.flipController.stopMove() : this.flipController.flip(t)));
        }
    }),
        Object.defineProperty(t, "__esModule", { value: !0 });
});

